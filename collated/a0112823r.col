//@author: a0112823r



	/**
	 * origin: E:\main\src\parser\DateParser.java
	 */

 *
 */
public class DateParser {

    private final String DDMMYYYY_KEYWORD = "\\b\\d+([/.-]\\d+[/.-]\\d+|[/.-]\\d+\\b)\\b";
    private final String DD_MONNTHINWORD_YYYY_KEYWORD = "\\b(\\w+|)(-|)\\w+(th|nd|rd|st|)(\\s|\\S)(of |)(january\\b|febuary\\b|march\\b|april\\b|may\\b|june\\b|july\\b|august\\b"
            + "|september\\b|octobor\\b|november\\b|december\\b)(\\s|)((in (the|) (year|yr)(s|))|)(\\s|)(\\d+\\b|)";
    private final String DD_SHORTFORMMONTHINWORD_YYYY_KEYWORD = "\\b(\\w+|)(-|)\\w+(th|nd|rd|st|)(\\s|\\S)(of |)(jan\\b|feb\\b|mar\\b|apr\\b|may\\b|jun\\b|jul\\b|aug\\b"
            + "|sep\\b|oct\\b|nov\\b|dec\\b)(\\s|\\S)((in (the|) (year|yr)(s|))|)(\\s|)(\\d+\\b|)";
    private final String AFTER_DAYS_APART_KEYWORD = "((\\w+|\\w+-\\w+) day(s|) later)\\b|\\bafter (\\w+|\\w+-\\w+) day(s|)\\b|\\b(\\w+|\\w+-\\w+) day(s|) after\\b";
    private final String DAYS_APART_VOCAB_KEYWORD = "(\\btmr\\b|\\b(the\\s|)following day(s|)\\b|\\b(after today)"
            + "\\b|\\b(after (tomorrow|tmr)\\b)|(\\bfortnight\\b)\\b)";
    private final String THIS_WEEKDAY_APART_KEYWORD = "\\b(on|by|due on|due|from|to|at|@|this)( this|)\\s(mon|tues|wed|thurs|fri|sat|sun)(day|nesday|urday|)(s|)\\b";
    private final String NEXT_WEEKDAY_APART_KEYWORD = "\\b(on|by|due on|due|from|to|at|@|next)( next|) (mon|tues|wed|thurs|fri|sat|sun)(day|nesday|urday|)(s|)\\b";
    private final String WEEKS_MONTHS_YEARS_APART_KEYWORD = "\\b((\\w+|\\w+-\\w+) (week|wk|month|mth|year|yr)(s|) later\\b)|\\bafter (\\w+|\\w+-\\w+) (week|wk|month|mth|year|yr)(s|)\\b|"
            + "\\b(\\w+|\\w+-\\w+) (week|wk|month|mth|year|yr)(s|) after\\b";
    private final String THIS_WEEK_MONTH_YEAR_KEYWORD = "\\bthis (week|wk)(s|)\\b|\\bthis (month|mth)(s|)\\b|\\bthis (year|yr)(s|)\\b";
    private final String TO_BE_REMOVED_KEYWORD = "\\b(@ |due on |on |at |from |to |by |due |next |this |((in (the|) (year|yr)(s|))))\\b";
    private final String DATE_FORMAT = "dd/MM/yyyy";
    private final int WEEK_UNIT = 7;
    private final int FORTNIGHT_UNIT = 14;
    private String inputLeft;
    private int index;
    private ArrayList<String> storageOfDate = new ArrayList<String>();

    public DateParser() {

    }

    public DateParser(String userInput) throws IllegalArgumentException {
        extractDate(userInput, userInput);
    }

    public void extractDate(String userInput, String leftOverInput)
            throws IllegalArgumentException {
        userInput = switchAllToLowerCase(userInput);
        leftOverInput = switchAllToLowerCase(leftOverInput);
        inputLeft = leftOverInput;
        goThroughDetectionMethod(userInput);
    }

    /**
     * to prevent case sensitive, switch all to lower case
     * 
     * @param userInput
     * @return the user input all in lower case.
     */
    private String switchAllToLowerCase(String userInput) {
        userInput = userInput.replaceAll("\\s+", " ");
        userInput = " " + userInput.toLowerCase() + " ";
        return userInput;
    }

    /**
     * get the input left after removing all the date detected
     * 
     * @return the input left after removing all the date detected
     */
    public String getInputLeft() {
        return inputLeft;
    }

    /**
     * 
     * @return String in the format of dd/mm/yyyy and return the current date if
     *         nothing is detected
     */
    public ArrayList<String> getDateList() {
        return storageOfDate;
    }

    /**
     * get the last index of the position of date detected in user input
     * 
     * @return last index
     */
    public int getIndex() {
        return index;
    }

    private void goThroughDetectionMethod(String userInput)
            throws IllegalArgumentException {

        spotDDMonthInWordYYYY(userInput, DD_MONNTHINWORD_YYYY_KEYWORD);
        spotDDMonthInWordYYYY(userInput, DD_SHORTFORMMONTHINWORD_YYYY_KEYWORD);
        spotDDMMYYYYKeyword(userInput);
        spotAfterDaysApartKeyword(userInput);
        spotDaysApartVocab(userInput);
        spotWeekMonthYearApartKeyword(userInput);
        spotThisWeekMonthYearKeyword(userInput);
        spotThisWeekdayApartKeyWord(userInput);
        spotNextWeekdayApartKeyWord(userInput);

    }

    /**
     * spot this week, month, year means date of end of this week, end of this
     * month and end of this year
     * 
     * @param userInput
     */
    private void spotThisWeekMonthYearKeyword(String userInput) {
        String dateOfTheTask = "";
        Pattern dateDetector = Pattern.compile(THIS_WEEK_MONTH_YEAR_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            String date = containDate.group();
            inputLeft = inputLeft.replaceAll(date, "");

            Calendar calendar = Calendar.getInstance();
            int month = calendar.get(Calendar.MONTH) + 1;
            int year = calendar.get(Calendar.YEAR);

            if (date.contains("week") || date.contains("wk")) {
                dateOfTheTask = getDateForThisWeek(calendar);

            } else if (date.contains("month") || date.contains("mth")) {
                dateOfTheTask = getDateForThisMonth(calendar, month, year);

            } else if (date.contains("year") || date.contains("yr")) {
                dateOfTheTask = getDateForThisYear(calendar, year);
            }

            storageOfDate.add(dateOfTheTask);
            int indexMatched = toGetIndex.start();
            setThePosition(indexMatched);
        }
    }

    private String getDateForThisWeek(Calendar calendar) {
        int todayDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;
        String dateOfTheTask = getThisWeekayDate(WEEK_UNIT, todayDayOfWeek);
        return dateOfTheTask;
    }

    private String getDateForThisYear(Calendar calendar, int year) {
        // set the month to dec (11 is dec month num)
        calendar.set(Calendar.MONTH, 11);

        int maxDaysOfDec = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

        String dateOfTheTask = getDateFromCalendar(calendar, year,
                maxDaysOfDec, 12);
        return dateOfTheTask;
    }

    private String getDateForThisMonth(Calendar calendar, int month, int year) {

        int maxDaysOfAMonth = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);
        String dateOfTheTask = getDateFromCalendar(calendar, year,
                maxDaysOfAMonth, month);
        return dateOfTheTask;
    }

    private String getDateFromCalendar(Calendar calendar, int year, int day,
            int month) {

        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        setDateIntoCalendar(day, month - 1, year, calendar);
        String dateOfTheTask = dateFormat.format(calendar.getTime());

        return dateOfTheTask;
    }

    /**
     * spot date of next mon-sun could be in short form(mon-sun) or
     * monday-sunday
     * 
     * @param userInput
     * @param storageOfDate
     * @return date in DD/MM/YYYY format
     */
    private void spotNextWeekdayApartKeyWord(String userInput) {
        String dateOfTheTask = "", nextWeekdayInput = "";
        Pattern dateDetector = Pattern.compile(NEXT_WEEKDAY_APART_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            nextWeekdayInput = containDate.group();
            inputLeft = inputLeft.replaceAll(nextWeekdayInput, "");

            Calendar calendar = Calendar.getInstance();
            int todayDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;

            nextWeekdayInput = nextWeekdayInput.trim();
            nextWeekdayInput = removeUnwantedParts(nextWeekdayInput);

            int dayOfTheWeek = WeekDayParser.detectDayOfWeek(nextWeekdayInput);

            dateOfTheTask = getNextWeekayDate(dayOfTheWeek, todayDayOfWeek);
            storageOfDate.add(dateOfTheTask);

            int indexMatched = toGetIndex.start();
            setThePosition(indexMatched);
        }
    }

    /**
     * get the final date after day of weeks is being added
     * 
     * @param dateOfTheTask
     * @param dayOfTheWeek
     * @param todayDayOfWeek
     * @return date in DD/MM/YYYY
     */
    private String getNextWeekayDate(int dayOfTheWeek, int todayDayOfWeek) {
        String dateOfTheTask = "";

        if (todayDayOfWeek == dayOfTheWeek) {
            dateOfTheTask = addToTheCurrentDateByDays(WEEK_UNIT);
        } else {
            dateOfTheTask = addToTheCurrentDateByDays(WEEK_UNIT
                    - todayDayOfWeek + dayOfTheWeek);
        }

        return dateOfTheTask;
    }

    /**
     * detect after no weeks, after no months, after no years s is not sensitive
     * 
     * @param userInput
     */
    private void spotWeekMonthYearApartKeyword(String userInput) {
        String dateOfTheTask = "";

        Pattern dateDetector = Pattern
                .compile(WEEKS_MONTHS_YEARS_APART_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher matchWithIndex = dateDetector.matcher(userInput);

        while (containDate.find() && matchWithIndex.find()) {
            String uniqueKeyword = containDate.group();
            inputLeft = inputLeft.replaceAll(uniqueKeyword, "");

            if (uniqueKeyword.contains("week") || uniqueKeyword.contains("wk")) {

                dateOfTheTask = getWeekApartDate(uniqueKeyword);
            } else if (uniqueKeyword.contains("month")
                    || uniqueKeyword.contains("mth")) {

                dateOfTheTask = getMonthApartDate(uniqueKeyword);
            } else if (uniqueKeyword.contains("year")
                    || uniqueKeyword.contains("yr")) {

                dateOfTheTask = getYearApartDate(uniqueKeyword);
            }

            storageOfDate.add(dateOfTheTask);

            int indexMatched = matchWithIndex.start();
            setThePosition(indexMatched);
        }
    }

    /**
     * get the date after number of year
     * 
     * @param uniqueKeyword
     * @return date in dd/mm/yyyy
     */
    private String getYearApartDate(String uniqueKeyword) {
        String dateOfTheTask;
        int numberOfYears;
        numberOfYears = getNumberOfYearsDetected(uniqueKeyword);
        dateOfTheTask = addToTheCurrentDateByYear(numberOfYears);
        return dateOfTheTask;
    }

    /**
     * get date after num of month
     * 
     * @param uniqueKeyword
     * @return date in dd/mm/yyyy
     */
    private String getMonthApartDate(String uniqueKeyword) {
        String dateOfTheTask;
        int numberOfMonths;
        numberOfMonths = getNumberOfMonthDetected(uniqueKeyword);
        dateOfTheTask = addToTheCurrentDateByMonth(numberOfMonths);
        return dateOfTheTask;
    }

    /**
     * get the date after number of week
     * 
     * @param uniqueKeyword
     * @return date in dd/mm/yyyy
     */
    private String getWeekApartDate(String uniqueKeyword) {
        String dateOfTheTask;
        int numberOfDays;
        numberOfDays = getNumberOfDaysDetected(uniqueKeyword);
        dateOfTheTask = addToTheCurrentDateByDays(numberOfDays);
        return dateOfTheTask;
    }

    /**
     * spot date of this mon-sun could be in short form(mon-sun) or
     * monday-sunday
     * 
     * @param userInput
     */
    private void spotThisWeekdayApartKeyWord(String userInput) {
        String dateOfTheTask = "", thisWeekdayInput = "";

        Pattern dateDetector = Pattern.compile(THIS_WEEKDAY_APART_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            thisWeekdayInput = containDate.group();
            inputLeft = inputLeft.replaceAll(thisWeekdayInput, "");
            thisWeekdayInput = thisWeekdayInput.trim();
            Calendar calendar = Calendar.getInstance();
            int todayDayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;

            thisWeekdayInput = removeUnwantedParts(thisWeekdayInput);

            int dayOfTheWeek = WeekDayParser.detectDayOfWeek(thisWeekdayInput);

            dateOfTheTask = getThisWeekayDate(dayOfTheWeek, todayDayOfWeek);
            storageOfDate.add(dateOfTheTask);

            int indexMatched = toGetIndex.start();
            setThePosition(indexMatched);
        }
    }

    /**
     * get this week date
     * 
     * @param dateOfTheTask
     * @param dayOfTheWeek
     * @param todayDayOfWeek
     * @return DD/MM/YYYY
     */
    private String getThisWeekayDate(int dayOfTheWeek, int todayDayOfWeek) {
        String dateOfTheTask = "";

        dateOfTheTask = addToTheCurrentDateByDays(dayOfTheWeek - todayDayOfWeek);

        if (todayDayOfWeek > dayOfTheWeek) {
            JOptionPane.showMessageDialog(null,
                    "Take note: Weekday entered have passed.");
        }

        return dateOfTheTask;
    }

    /**
     * detect tomorrow, the following day, after tomorrow, after today
     * 
     * @param userInput
     */
    private void spotDaysApartVocab(String userInput) {
        String dateOfTheTask = "";

        Pattern dateDetector = Pattern.compile(DAYS_APART_VOCAB_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            String daysApartVocab = containDate.group();
            inputLeft = inputLeft.replaceAll(DAYS_APART_VOCAB_KEYWORD, "");

            int numberOfDays = getNumberOfDaysDetected(daysApartVocab);

            dateOfTheTask = addToTheCurrentDateByDays(numberOfDays);
            storageOfDate.add(dateOfTheTask);

            int indexMatch = toGetIndex.start();
            setThePosition(indexMatch);
        }

    }

    /**
     * set the start and end date in the right position in arrayList
     * 
     * @param indexMatch
     */
    private void setThePosition(int indexMatch) {
        String temp;

        if (storageOfDate.size() == 2 && indexMatch < index) {
            temp = storageOfDate.get(0);
            storageOfDate.set(0, storageOfDate.get(1));
            storageOfDate.set(1, temp);
        }

        index = indexMatch;
    }

    private String addToTheCurrentDateByDays(int numberOfDay) {
        String dateOfTheTask = "";

        DateFormat date = new SimpleDateFormat(DATE_FORMAT);
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, numberOfDay);
        dateOfTheTask = date.format(cal.getTime());
        return dateOfTheTask;
    }

    /**
     * detect date: after (no. in word or int) days, next (no in word or int)
     * day is okay to have s behind or no s behind day
     * 
     * @param userInput
     */
    private void spotAfterDaysApartKeyword(String userInput) {
        String uniqueKeyword = "", dateOfTask = "";

        Pattern dateDetector = Pattern.compile(AFTER_DAYS_APART_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            uniqueKeyword = containDate.group();
            inputLeft = inputLeft.replaceAll(AFTER_DAYS_APART_KEYWORD, "");

            int numberOfDays = getNumberOfDaysDetected(uniqueKeyword);
            dateOfTask = addToTheCurrentDateByDays(numberOfDays);
            storageOfDate.add(dateOfTask);

            int indexMatched = toGetIndex.start();
            setThePosition(indexMatched);
        }
    }

    private int getNumberOfDaysDetected(String uniqueKeyword) {
        int numberOfDays = 0;

        uniqueKeyword = uniqueKeyword.trim();
        if (uniqueKeyword.equals("tmr")) {
            numberOfDays = 1;
        } else if (uniqueKeyword.contains("following day")) {
            numberOfDays = 1;
        } else if (uniqueKeyword.equals("after today")) {
            numberOfDays = 1;
        } else if (uniqueKeyword.equals("after tomorrow")
                || uniqueKeyword.equals("after tmr")) {
            numberOfDays = 2;
        } else if (uniqueKeyword.contains("week")
                || uniqueKeyword.contains("wk")) {

            uniqueKeyword = uniqueKeyword.replaceAll("\\bafter\\b", "");
            int numberOfWeek = NumberParser.getNumber(uniqueKeyword);
            numberOfDays = WEEK_UNIT * numberOfWeek;

        } else if (uniqueKeyword.contains("fortnight")) {

            int numberOfFornight = NumberParser.getNumber(uniqueKeyword);
            numberOfDays = FORTNIGHT_UNIT * numberOfFornight;
        } else {

            uniqueKeyword = uniqueKeyword.replaceAll("\\bafter\\b", "");
            numberOfDays = NumberParser.getNumber(uniqueKeyword);

        }

        return numberOfDays;
    }

    private int getNumberOfMonthDetected(String uniqueKeyword) {
        int numberOfMonth = 0;

        uniqueKeyword = uniqueKeyword.replaceAll("\\bafter\\b", "");

        if (uniqueKeyword.contains("month") || uniqueKeyword.contains("mth")) {
            numberOfMonth = NumberParser.getNumber(uniqueKeyword);
        }

        return numberOfMonth;
    }

    private int getNumberOfYearsDetected(String uniqueKeyword) {
        int numberOfYear = 0;

        uniqueKeyword = uniqueKeyword.replaceAll("\\bafter\\b", "");

        if (uniqueKeyword.contains("year") || uniqueKeyword.contains("yr")) {
            numberOfYear = NumberParser.getNumber(uniqueKeyword);
        }

        return numberOfYear;
    }

    private String addToTheCurrentDateByYear(int numberOfYear) {
        String dateOfTheTask = "";

        DateFormat date = new SimpleDateFormat(DATE_FORMAT);
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.YEAR, numberOfYear);
        dateOfTheTask = date.format(cal.getTime());

        return dateOfTheTask;
    }

    private String addToTheCurrentDateByMonth(int numberOfMonth) {
        String dateOfTheTask = "";

        DateFormat date = new SimpleDateFormat(DATE_FORMAT);
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.MONTH, numberOfMonth);
        dateOfTheTask = date.format(cal.getTime());

        return dateOfTheTask;
    }

    /**
     * detect DD Month in word/DD Month in word YYYY with space in between or no
     * space in between DD could be in 2 or 2nd or 2nd of , 2 or 3th or 3th of,
     * 4 or 4th or 4th of etc
     * 
     * @throws IllegalArgumentException
     *             : invalid month and exceed day in that month
     * @param userInput
     */
    private void spotDDMonthInWordYYYY(String userInput, String keyword)
            throws IllegalArgumentException {
        Pattern dateDetector = Pattern.compile(keyword);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            Calendar calendar = Calendar.getInstance();

            String dateOfTheTask = containDate.group();
            dateOfTheTask = removeUnwantedParts(dateOfTheTask);
            int day = NumberParser.getNumber(dateOfTheTask);
            int year = YearParser.getYear(dateOfTheTask);
            int month = MonthParser.convertMonthToNumber(dateOfTheTask);

            if (day == 0) {
                break;
            }
            assert month != 0 : "month need to be detected or keyed by user";

            testValidMonth(month);
            testValidDay(day, year, month);

            dateOfTheTask = getDateFromCalendar(calendar, year, day, month);
            storageOfDate.add(dateOfTheTask);
            inputLeft = inputLeft.replaceAll(keyword, "");

            int indexOfDatePosition = toGetIndex.start();
            setThePosition(indexOfDatePosition);
        }
    }

    private void setDateIntoCalendar(int day, int month, int year,
            Calendar calendar) {
        calendar.set(Calendar.DATE, day);
        if (year != 0) {
            calendar.set(Calendar.YEAR, year);
        }
        calendar.set(Calendar.MONTH, month);
    }

    /**
     * detct DD/MM and DD/MM/YYYY
     * 
     * @param userInput
     * @return date dd/mm/yyyy
     * @throws IllegalArgumentException
     *             : max day or month exceeded
     */
    private void spotDDMMYYYYKeyword(String userInput)
            throws IllegalArgumentException {
        Pattern dateDetector = Pattern.compile(DDMMYYYY_KEYWORD);
        Matcher containDate = dateDetector.matcher(inputLeft);
        Matcher toGetIndex = dateDetector.matcher(userInput);

        while (containDate.find() && toGetIndex.find()) {
            Calendar calendar = Calendar.getInstance();
            inputLeft = inputLeft.replaceAll(DDMMYYYY_KEYWORD, "");

            String dateOfTheTask = containDate.group();

            dateOfTheTask = removeUnwantedParts(dateOfTheTask);

            int day = NumberParser.getNumber(dateOfTheTask);
            int year = YearParser.getYear(dateOfTheTask);
            int month = MonthParser.getMonth(dateOfTheTask);

            testValidMonth(month);
            testValidDay(day, year, month);

            dateOfTheTask = getDateFromCalendar(calendar, year, day, month);
            storageOfDate.add(dateOfTheTask);

            int indexPositionOfThisDate = toGetIndex.start();
            setThePosition(indexPositionOfThisDate);
        }
    }

    /**
     * throws and catch exception of invalid month
     * 
     * @param month
     * @throws IllegalArgumentException
     *             : month exceed 12
     */
    private void testValidMonth(int month) throws IllegalArgumentException {
        Logger logger = Logger.getLogger("DateParser");
        try {
            logger.log(Level.INFO,
                    "going to start processing for invalid month");

            if (month <= 0 || month > 12) {
                throw new IllegalArgumentException("Invalid Month Keyed!");
            }
        } catch (IllegalArgumentException e) {
            logger.log(Level.FINER, "Invalid Month Keyed!");
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * check if the date is valid if the year and the month have this day For
     * example feb only have max 29 days
     * 
     * @param day
     * @throws IllegalArgumentException
     *             : day exceed max day
     */
    private void testValidDay(int day, int year, int month)
            throws IllegalArgumentException {
        Logger logger = Logger.getLogger("DateParser");
        try {
            logger.log(Level.INFO,
                    "going to start processing for invalid day that pass max day");
            Calendar calendar = Calendar.getInstance();

            if (year != 0) {
                calendar.set(Calendar.YEAR, year);
            }
            calendar.set(Calendar.MONTH, month - 1);

            int maxDays = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

            if (day == 0 || maxDays < day) {
                throw new IllegalArgumentException(
                        "Invalid Day Keyed! Exceed the maximum day in that month");
            }

        } catch (IllegalArgumentException e) {
            logger.log(Level.FINER,
                    "Invalid Day Keyed! Exceed the maximum day in that month");
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    public String removeUnwantedParts(String timeWithUnwantedPart) {
        String time;
        timeWithUnwantedPart = timeWithUnwantedPart.trim();
        time = timeWithUnwantedPart.replaceAll(TO_BE_REMOVED_KEYWORD, "");
        return time;
    }
}

	// End of segment: E:\main\src\parser\DateParser.java





	/**
	 * origin: E:\main\src\parser\DateParserTest.java
	 */

 *
 */
public class DateParserTest {

    @Test
    /*
     * test DD/MM/YYYY format
     */
    public void testDDMMYYY() {
        ArrayList<String> dates = new ArrayList<String>();
        // test without year
        dates.add("01/03/2015");
        DateParser d1 = new DateParser(("mds sale due 1/3 2:30am"));
        assertEquals(dates, d1.getDateList());

        // test date with year
        dates.clear();
        dates.add("01/03/2016");
        DateParser d2 = new DateParser(("1/3/2016."));
        assertEquals(dates, d2.getDateList());

        // test without year with -
        dates.clear();
        dates.add("01/03/2015");
        DateParser d4 = new DateParser(("mds sale due 1-3 2:30am"));
        assertEquals(dates, d4.getDateList());

        // test date with year with -
        dates.clear();
        dates.add("01/03/2016");
        DateParser d5 = new DateParser(("1-3-2016"));
        assertEquals(dates, d5.getDateList());

        // test without year with .
        dates.clear();
        dates.add("01/03/2015");
        DateParser d7 = new DateParser(("mds sale due 1.3 2:30am"));
        assertEquals(dates, d7.getDateList());

        // test date with year with -
        dates.clear();
        dates.add("01/03/2016");
        DateParser d8 = new DateParser(("1.3.2016."));
        assertEquals(dates, d8.getDateList());

    }

    @Test
    /*
     * test Day month in word Year date format 1) the format itself with year 2)
     * the format itself without year 3) case sensitively 4)space sensitively
     */
    public void testDDMonthInWordYYYY() {
        ArrayList<String> dates = new ArrayList<String>();
        // test date without year
        dates.clear();
        dates.add("12/09/2015");
        DateParser d1 = new DateParser(("krej lpp at 12 september."));
        assertEquals(dates, d1.getDateList());

        // test date with year
        dates.clear();
        dates.add("20/12/2016");

        DateParser d2 = new DateParser(("krej lpp at 20 december 2016"));
        assertEquals(dates, d2.getDateList());

        // test the case sensitivity
        dates.clear();
        dates.add("12/10/2015");

        DateParser d3 = new DateParser(("krej lpp at 12 OcToBor 3pm"));
        assertEquals(dates, d3.getDateList());

        // test with th
        dates.clear();
        dates.add("12/10/2015");

        DateParser d4 = new DateParser(("krej lpp at 12th OcToBor 3pm"));
        assertEquals(dates, d4.getDateList());

        // test with rd
        dates.clear();
        dates.add("03/09/2015");

        DateParser d5 = new DateParser(("krej lpp at 3rd september 3pm"));
        assertEquals(dates, d5.getDateList());

        // test with nd
        dates.clear();
        dates.add("02/04/2015");
        DateParser d6 = new DateParser(("krej lpp at 2nd april 3pm"));
        assertEquals(dates, d6.getDateList());

        // test with st
        dates.clear();
        dates.add("21/04/2015");
        DateParser d7 = new DateParser(("krej lpp at 21st april 3pm"));
        assertEquals(dates, d7.getDateList());

        // test with word 1-9
        dates.clear();
        dates.add("05/05/2015");
        DateParser d8 = new DateParser(("krej lpp at five may 3pm"));
        assertEquals(dates, d8.getDateList());

        // test with word 10-19
        dates.clear();
        dates.add("11/05/2015");
        DateParser d9 = new DateParser(("krej lpp at eleven may 3pm"));
        assertEquals(dates, d9.getDateList());

        // test with word 20-29
        dates.clear();
        dates.add("23/05/2015");
        DateParser d10 = new DateParser(("krej lpp at twenty-three may 3pm"));
        assertEquals(dates, d10.getDateList());

        // test with word 30-32
        dates.clear();
        dates.add("30/05/2015");
        DateParser d11 = new DateParser(("krej lpp at thirty may 3pm"));
        assertEquals(dates, d11.getDateList());

    }

    @Test
    /*
     * test Day shortcut month in word Year date format 1) the format itself
     * with year 2) the format itself without year 3) case sensitively 4)space
     * sensitively
     */
    public void testDDShortFormMonthInWordYYYY() {
        ArrayList<String> dates = new ArrayList<String>();

        // test 4th of April in the year of 2015 in sentence
        dates.clear();
        dates.add("04/04/2015");
        DateParser d = new DateParser(
                "mummy is nagging 4th of April in the year of 2015");
        assertEquals(dates, d.getDateList());

        // test without year
        dates.clear();
        dates.add("12/01/2015");
        DateParser d1 = new DateParser(("mds sale at 12 jan."));
        assertEquals(dates, d1.getDateList());

        // test date with year
        dates.clear();
        dates.add("13/03/2014");
        DateParser d2 = new DateParser(("mds sale 13 mar 2014"));
        assertEquals(dates, d2.getDateList());

        // test case sensitivity
        dates.clear();
        dates.add("13/07/2014");
        DateParser d3 = new DateParser(("mds sale 13 JuL 2014"));
        assertEquals(dates, d3.getDateList());

        // test space sensitivity
        dates.clear();
        dates.add("18/12/2017");
        DateParser d4 = new DateParser(("mds sale 18dec 2017"));
        assertEquals(dates, d4.getDateList());

        // test date with th
        dates.clear();
        dates.add("13/04/2014");
        DateParser d5 = new DateParser(("mds sale 13th apr 2014"));
        assertEquals(dates, d5.getDateList());

        // test date with rd
        dates.clear();
        dates.add("03/06/2014");
        DateParser d6 = new DateParser(("mds sale 3rd jun 2014"));
        assertEquals(dates, d6.getDateList());

        // test date with nd
        dates.clear();
        dates.add("02/02/2014");
        DateParser d7 = new DateParser(("mds sale 2nd feb 2014"));
        assertEquals(dates, d7.getDateList());

        // test date with st
        dates.clear();
        dates.add("21/02/2014");
        DateParser d8 = new DateParser(("mds sale 21st feb 2014"));
        assertEquals(dates, d8.getDateList());

        // test with word 1-9
        dates.clear();
        dates.add("05/06/2015");
        DateParser d12 = new DateParser(("krej lpp at five jun 3pm"));
        assertEquals(dates, d12.getDateList());

        // test with word 10-19
        dates.clear();
        dates.add("11/06/2015");
        DateParser d9 = new DateParser(("krej lpp at eleven jun 3pm"));
        assertEquals(dates, d9.getDateList());

        // test with word 20-29
        dates.clear();
        dates.add("23/06/2015");
        DateParser d10 = new DateParser(("krej lpp at twenty-three jun 3pm"));
        assertEquals(dates, d10.getDateList());

        // test with word 30-32
        dates.clear();
        dates.add("30/06/2015");
        DateParser d11 = new DateParser(("krej lpp at thirty jun 3pm"));
        assertEquals(dates, d11.getDateList());
    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date + number of days Interpret by
     * the vocab current date of mine : 11/4/2015
     */
    public void testDaysApartVocabKeyword() {
        ArrayList<String> dates = new ArrayList<String>();
        // test keyword 5: tmr
        dates.clear();
        dates.add("12/04/2015");
        DateParser d1 = new DateParser(("mds sale from tmr"));
        assertEquals(dates, d1.getDateList());

        // test keyword 5: the following day
        dates.clear();
        dates.add("12/04/2015");

        DateParser d2 = new DateParser(("mds sale the following day"));
        assertEquals(dates, d2.getDateList());

        // test keyword 5: after tomorrow
        dates.clear();
        dates.add("13/04/2015");
        DateParser d4 = new DateParser(("mds sale after tomorrow"));
        assertEquals(dates, d4.getDateList());

        // test keyword 5: after tmr
        dates.clear();
        dates.add("13/04/2015");

        DateParser d5 = new DateParser(("mds sale after tmr"));
        assertEquals(dates, d5.getDateList());

        // test keyword 5: after today
        dates.clear();
        dates.add("12/04/2015");
        DateParser d6 = new DateParser(("mds sale after today"));
        assertEquals(dates, d6.getDateList());

        // test keyword 5: _ day later
        dates.clear();
        dates.add("12/04/2015");
        DateParser d7 = new DateParser(("mds sale one day later"));
        assertEquals(dates, d7.getDateList());

        // test keyword 5: _ day later in 4
        dates.clear();
        dates.add("15/04/2015");
        DateParser d8 = new DateParser(("mds sale 4 day later"));
        assertEquals(dates, d8.getDateList());

        // test keyword 5: _ day later in 4
        dates.clear();
        dates.add("03/05/2015");
        DateParser d9 = new DateParser(("mds sale twenty-two day later"));
        assertEquals(dates, d9.getDateList());

        // test keyword 5: after _ day
        dates.clear();
        dates.add("02/05/2015");
        DateParser d10 = new DateParser(("mds sale after twenty-one day"));
        assertEquals(dates, d10.getDateList());

        // test keyword 5: after _ day
        dates.clear();
        dates.add("12/04/2015");
        DateParser d11 = new DateParser(("mds sale after one day"));
        assertEquals(dates, d11.getDateList());

        // test keyword 5: after _ day
        dates.clear();
        dates.add("21/04/2015");
        DateParser d12 = new DateParser(("mds sale after 10 day"));
        assertEquals(dates, d12.getDateList());

        // test keyword 5: _ day after
        dates.clear();
        dates.add("02/05/2015");
        DateParser d13 = new DateParser(("mds sale twenty-one day after"));
        assertEquals(dates, d13.getDateList());

        // test keyword 5: _ day after
        dates.clear();
        dates.add("12/04/2015");
        DateParser d14 = new DateParser(("mds sale one day after"));
        assertEquals(dates, d14.getDateList());

        // test keyword 5: _ day after
        dates.clear();
        dates.add("21/04/2015");
        DateParser d15 = new DateParser(("mds sale 10 day after"));
        assertEquals(dates, d15.getDateList());
    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date + number of week/month/year
     * Interpret by the vocab Current date : 11/04/2015
     */
    public void testWeekMonthYearApartKeyword() {
        ArrayList<String> dates = new ArrayList<String>();
        // test keyword 6 : weeks later
        dates.clear();
        dates.add("18/04/2015");

        DateParser d1 = new DateParser("mds sale start 1 week later");
        assertEquals(dates, d1.getDateList());

        // test keyword 6 : wk later
        dates.clear();
        dates.add("18/04/2015");

        DateParser d3 = new DateParser("mds sale start 1 wk later");
        assertEquals(dates, d3.getDateList());

        // test keyword 6 : wk later
        dates.clear();
        dates.add("02/05/2015");

        DateParser d9 = new DateParser("mds sale start three wk later");
        assertEquals(dates, d9.getDateList());

        // test keyword 6 : month later
        dates.clear();
        dates.add("11/05/2015");

        DateParser d2 = new DateParser("mds sale start 1 month later");
        assertEquals(dates, d2.getDateList());

        // test keyword 6 : month later
        dates.clear();
        dates.add("11/05/2015");

        DateParser d4 = new DateParser("mds sale start 1 mth later");
        assertEquals(dates, d4.getDateList());

        // test keyword 6 : month later
        dates.clear();
        dates.add("11/06/2015");

        DateParser d8 = new DateParser("mds sale start two mth later");
        assertEquals(dates, d8.getDateList());

        // test keyword 6 : year later
        dates.clear();
        dates.add("11/04/2016");

        DateParser d5 = new DateParser("mds sale start 1 year later");
        assertEquals(dates, d5.getDateList());

        // test keyword 6 : yr later
        dates.clear();
        dates.add("11/04/2016");

        DateParser d6 = new DateParser("mds sale start 1 yr later");
        assertEquals(dates, d6.getDateList());

        // test keyword 6 : yr later in word
        dates.clear();
        dates.add("11/04/2027");

        DateParser d7 = new DateParser("mds sale start twelve yr later");
        assertEquals(dates, d7.getDateList());

        // test keyword 5: after _ year
        dates.clear();
        dates.add("11/04/2016");
        DateParser d12 = new DateParser(("mds sale after 1 yr"));
        assertEquals(dates, d12.getDateList());

        // test keyword 5: after _ year
        dates.clear();
        dates.add("11/04/2027");
        DateParser d19 = new DateParser(("mds sale after twelve yr"));
        assertEquals(dates, d19.getDateList());

        // test keyword 5: after _ year
        dates.clear();
        dates.add("11/04/2037");
        DateParser d20 = new DateParser(("mds sale after twenty-two year"));
        assertEquals(dates, d20.getDateList());

        // test keyword 5: __ year after
        dates.clear();
        dates.add("11/04/2036");
        DateParser d13 = new DateParser(("mds sale twenty-one year after"));
        assertEquals(dates, d13.getDateList());

        // test keyword 5: _ year after
        dates.clear();
        dates.add("11/04/2016");
        DateParser d14 = new DateParser(("mds sale one year after"));
        assertEquals(dates, d14.getDateList());

        // test keyword 5: _ year after
        dates.clear();
        dates.add("11/04/2025");
        DateParser d15 = new DateParser(("mds sale 10 year after"));
        assertEquals(dates, d15.getDateList());

        // test keyword 5: after _ week
        dates.clear();
        dates.add("18/04/2015");
        DateParser d16 = new DateParser(("mds sale after 1 wk"));
        assertEquals(dates, d16.getDateList());

        // test keyword 5: after _ week
        dates.clear();
        dates.add("04/07/2015");
        DateParser d17 = new DateParser(("mds sale after twelve wk"));
        assertEquals(dates, d17.getDateList());

        // test keyword 5: after _ week
        dates.clear();
        dates.add("12/09/2015");
        DateParser d18 = new DateParser(("mds sale after twenty-two week"));
        assertEquals(dates, d18.getDateList());

        // test keyword 5: __ week after
        dates.clear();
        dates.add("05/09/2015");
        DateParser d21 = new DateParser(("mds sale twenty-one week after"));
        assertEquals(dates, d21.getDateList());

        // test keyword 5: _ week after
        dates.clear();
        dates.add("18/04/2015");
        DateParser d22 = new DateParser(("mds sale one week after"));
        assertEquals(dates, d22.getDateList());

        // test keyword 5: _ week after
        dates.clear();
        dates.add("20/06/2015");
        DateParser d23 = new DateParser(("mds sale 10 week after"));
        assertEquals(dates, d23.getDateList());

        // test keyword 5: after _ month
        dates.clear();
        dates.add("11/05/2015");
        DateParser d24 = new DateParser(("mds sale after 1 mth"));
        assertEquals(dates, d24.getDateList());

        // test keyword 5: after _ month
        dates.clear();
        dates.add("11/04/2016");
        DateParser d25 = new DateParser(("mds sale after twelve mth"));
        assertEquals(dates, d25.getDateList());

        // test keyword 5: after _ month
        dates.clear();
        dates.add("11/02/2017");
        DateParser d26 = new DateParser(("mds sale after twenty-two month"));
        assertEquals(dates, d26.getDateList());

        // test keyword 5: __ month after
        dates.clear();
        dates.add("11/01/2017");
        DateParser d27 = new DateParser(("mds sale twenty-one month after"));
        assertEquals(dates, d27.getDateList());

        // test keyword 5: _ month after
        dates.clear();
        dates.add("11/05/2015");
        DateParser d28 = new DateParser(("mds sale one month after"));
        assertEquals(dates, d28.getDateList());

        // test keyword 5: _ month after
        dates.clear();
        dates.add("11/02/2016");
        DateParser d29 = new DateParser(("mds sale 10 month after"));
        assertEquals(dates, d29.getDateList());
    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date to this mon/tues.../fri And
     * if today weekday pass the this weekday you keyed --> error Current date :
     * 06/04/2015 MON
     */
    public void testThisWeekdayKeyword() {
        ArrayList<String> dates = new ArrayList<String>();

        dates.add("12/04/2015");
        DateParser d1 = new DateParser("mds sale this sun");
        assertEquals(dates, d1.getDateList());

        // test full form of weekday and change to on
        dates.clear();
        dates.add("12/04/2015");
        DateParser d2 = new DateParser("mds sale on sunday");
        assertEquals(dates, d2.getDateList());

        dates.clear();
        dates.add("06/04/2015");
        DateParser d3 = new DateParser("mds sale this mon");
        assertEquals(dates, d3.getDateList());

        // test full form of weekday and change to by
        dates.clear();
        dates.add("06/04/2015");
        DateParser d5 = new DateParser("mds sale by monday");
        assertEquals(dates, d5.getDateList());

        dates.clear();
        dates.add("07/04/2015");
        DateParser d4 = new DateParser("mds sale this tues");
        assertEquals(dates, d4.getDateList());

        // test full form of weekday and change to due on
        dates.clear();
        dates.add("07/04/2015");
        DateParser d6 = new DateParser("mds sale due on tuesday");
        assertEquals(dates, d6.getDateList());

        dates.clear();
        dates.add("08/04/2015");
        DateParser d7 = new DateParser("mds sale this wed");
        assertEquals(dates, d7.getDateList());

        // test full form of weekday and change to on
        dates.clear();
        dates.add("08/04/2015");
        DateParser d9 = new DateParser("mds sale due wednesday");
        assertEquals(dates, d9.getDateList());

        dates.clear();
        dates.add("09/04/2015");
        DateParser d8 = new DateParser("mds sale this thurs");
        assertEquals(dates, d8.getDateList());

        // test full form of weekday and change to at
        dates.clear();
        dates.add("09/04/2015");
        DateParser d12 = new DateParser("mds sale at thursday");
        assertEquals(dates, d12.getDateList());

        // change to from
        dates.clear();
        dates.add("10/04/2015");
        DateParser d10 = new DateParser("mds sale from fri");
        assertEquals(dates, d10.getDateList());

        // test full form of weekday and change to
        dates.clear();
        dates.add("10/04/2015");
        DateParser d11 = new DateParser("mds sale to fri");
        assertEquals(dates, d11.getDateList());

    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date to next mon/tues.../fri
     * current date : 10/4/2015
     */
    public void testWeekDayApartKeyword() {
        ArrayList<String> dates = new ArrayList<String>();

        dates.add("19/04/2015");
        DateParser d1 = new DateParser("mds sale next sun");
        assertEquals(dates, d1.getDateList());

        // test full form of weekday and change to on
        dates.clear();
        dates.add("19/04/2015");
        DateParser d2 = new DateParser("mds sale on next sunday");
        assertEquals(dates, d2.getDateList());

        dates.clear();
        dates.add("13/04/2015");
        DateParser d3 = new DateParser("mds sale next mon");
        assertEquals(dates, d3.getDateList());

        // test full form of weekday and change to by
        dates.clear();
        dates.add("13/04/2015");
        DateParser d5 = new DateParser("mds sale by next monday");
        assertEquals(dates, d5.getDateList());

        dates.clear();
        dates.add("14/04/2015");
        DateParser d4 = new DateParser("mds sale next tues");
        assertEquals(dates, d4.getDateList());

        // test full form of weekday and change to due on
        dates.clear();
        dates.add("14/04/2015");
        DateParser d6 = new DateParser("mds sale due on next tuesday");
        assertEquals(dates, d6.getDateList());

        dates.clear();
        dates.add("15/04/2015");
        DateParser d7 = new DateParser("mds sale next wed");
        assertEquals(dates, d7.getDateList());

        // test full form of weekday and change to on
        dates.clear();
        dates.add("15/04/2015");
        DateParser d9 = new DateParser("mds sale due next wednesday");
        assertEquals(dates, d9.getDateList());

        dates.clear();
        dates.add("16/04/2015");
        DateParser d8 = new DateParser("mds sale next thurs");
        assertEquals(dates, d8.getDateList());

        // test full form of weekday and change to at
        dates.clear();
        dates.add("16/04/2015");
        DateParser d12 = new DateParser("mds sale at next thursday");
        assertEquals(dates, d12.getDateList());

        // change to from
        dates.clear();
        dates.add("17/04/2015");
        DateParser d10 = new DateParser("mds sale next fri");
        assertEquals(dates, d10.getDateList());

        // test full form of weekday and change to
        dates.clear();
        dates.add("17/04/2015");
        DateParser d11 = new DateParser("mds sale to next friday");
        assertEquals(dates, d11.getDateList());
    }

    @Test
    /*
     * for day keyed exceeded the max day in that month, program auto set it by
     * plus the number of day exceeded to the current date eg: 30/02/2015 -->
     * 02/03/2015 max: 28 days in feb 2015 will appear a window
     */
    public void testDateError() {
        ArrayList<String> dates = new ArrayList<String>();

        DateParser d1 = new DateParser(("mds sale 30 feb 2015"));

    }

    @Test
    /*
     * 1st 20 Dec 2014 will be detect and then 20/3 will be detected check if
     * the position of the date stored is right position 20/3 -->20 Dec 2014
     */
    public void testPosition() {
        ArrayList<String> dates = new ArrayList<String>();

        dates.add("20/03/2015");
        dates.add("20/12/2014");
        DateParser d1 = new DateParser(("mds sale 20/3 to 20 Dec 2014"));
        assertEquals(dates, d1.getDateList());
    }

    @Test
    // PS current date : 10/4/2015 make changes based on ur current date
    public void testThisWeekMonthYear() {
        ArrayList<String> dates = new ArrayList<String>();

        dates.add("31/12/2015");
        DateParser d1 = new DateParser(("mds sale this year"));
        assertEquals(dates, d1.getDateList());

        // change to yr
        dates.clear();
        dates.add("31/12/2015");
        DateParser d2 = new DateParser(("mds sale this yr"));
        assertEquals(dates, d2.getDateList());

        // change to yr with s
        dates.clear();
        dates.add("31/12/2015");
        DateParser d3 = new DateParser(("mds sale this yrs"));
        assertEquals(dates, d3.getDateList());

        // change to month
        dates.clear();
        dates.add("30/04/2015");
        DateParser d4 = new DateParser(("mds sale this month"));
        assertEquals(dates, d4.getDateList());

        // change to mth
        dates.clear();
        dates.add("30/04/2015");
        DateParser d5 = new DateParser(("mds sale this mth"));
        assertEquals(dates, d5.getDateList());

        // change to mth with s
        dates.clear();
        dates.add("30/04/2015");
        DateParser d6 = new DateParser(("mds sale this mths"));
        assertEquals(dates, d6.getDateList());

        // change to week with s
        dates.clear();
        dates.add("12/04/2015");
        DateParser d7 = new DateParser(("mds sale this weeks"));
        assertEquals(dates, d7.getDateList());

        // change to week
        dates.clear();
        dates.add("12/04/2015");
        DateParser d8 = new DateParser(("mds sale this week"));
        assertEquals(dates, d8.getDateList());

        // change to wk
        dates.clear();
        dates.add("12/04/2015");
        DateParser d9 = new DateParser(("mds sale this wk"));
        assertEquals(dates, d9.getDateList());

        // when there is both wk and month
        dates.clear();
        dates.add("12/04/2015");
        dates.add("30/04/2015");
        DateParser d10 = new DateParser(("mds sale this wk and this month"));
        assertEquals(dates, d10.getDateList());
    }

}

	// End of segment: E:\main\src\parser\DateParserTest.java





	/**
	 * origin: E:\main\src\parser\DateTimeNattyParser.java
	 */

 *
 */
public class DateTimeNattyParser {
    private final String MONNTHINWORD_DD_YYYY_KEYWORD = "\\b(january|febuary|march|april|may|june|july|august|september|octobor|november|december)"
            + "|(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(\\s|)(\\w+|)(-|)\\w+(th|nd|rd|st|)(\\s|)(\\d+|)\\b";
    private final String HOUR_FORMAT_KEYWORD = "\\b\\d+(\\s|)(hour|hr)(s|)\\b";
    private ArrayList<String> storageOfDate = new ArrayList<String>();
    private ArrayList<String> storageOfTime = new ArrayList<String>();
    private String userInputLeftAfterParsing;
    private String description;
    private int indexTime;
    private int indexDate;

    public DateTimeNattyParser() {

    }

    public DateTimeNattyParser(String userInput) {
        extractDateTime(userInput, userInput, storageOfDate, storageOfTime, 0,
                0);
    }

    public void extractDateTime(String userInput, String leftOverInput,
            ArrayList<String> dates, ArrayList<String> times,
            int indexPrevTime, int indexPrevDate)
            throws IllegalArgumentException {

        storageOfDate.clear();
        storageOfTime.clear();
        storageOfDate.addAll(dates);
        storageOfTime.addAll(times);

        indexTime = indexPrevTime;
        indexDate = indexPrevDate;

        // userInputLeftAfterParsing : remove those detected --> prevent
        // infinite loop
        userInputLeftAfterParsing = leftOverInput;
        userInputLeftAfterParsing = switchAllToLowerCase(userInputLeftAfterParsing);
        userInput = switchAllToLowerCase(userInput);

        // description --> remove those that is detected and used.(like eve
        // detect but will be discarded)
        description = leftOverInput;

        testValidTime(userInputLeftAfterParsing);
        testValidDate(userInputLeftAfterParsing);

        extractDateAndTime(userInput);
    }

    private void extractDateAndTime(String userInput) {
        List<DateGroup> groups = new ArrayList<DateGroup>();
        
        Parser dateTimeParser = new Parser();
        while (!dateTimeParser.parse(userInputLeftAfterParsing).isEmpty()) {
            groups = dateTimeParser.parse(userInputLeftAfterParsing);
            parseDateAndTime(groups, userInput);
        }
    }

    /**
     * to prevent case sensitive, switch all to lower case
     * 
     * @param userInput
     * @return the user input all in lower case.
     */
    private String switchAllToLowerCase(String userInput) {
        userInput = userInput.replaceAll("\\s+", " ");
        userInput = " " + userInput.toLowerCase() + " ";
        return userInput;
    }

    /**
     * get the left over of user input after all detection of time and date
     * 
     * @return part of description
     */
    public String getDescription() {
        return description;
    }

    /**
     * get the date time list containing date and time in <weekday> <dd/mm/yyy>
     * 
     * @return a list containing date in <weekday> <dd/mm/yyyy>
     */

    public ArrayList<String> getDateList() {
        return storageOfDate;
    }

    /**
     * get the date time list containing date and time in <hh:mm>
     * 
     * @return a list containing date and time in <hh:mm>
     */
    public ArrayList<String> getTimeList() {
        return storageOfTime;
    }

    /**
     * 1. change the date to String 2. change from<weekday> <month in word>
     * <day> <HH:mm:ss> <timezone> <year> to <weekday> <day/month/year> <hh:mm>
     * 3. bypass those like eve that should be in description
     * 
     * @param dates
     *            : contains all of the date detected
     * @param parseMapF
     *            : contains which date and time is detected
     */

    private void changeDateFormat(List<Date> dates,
            Map<String, List<ParseLocation>> parseMap, String matchingValue,
            int position) {

        for (int i = 0; i < dates.size(); i++) {
            String time = getTime(dates.get(i));
            String date = getDate(dates.get(i));

            if (parseMap.containsKey("date")
                    && i + 1 <= parseMap.get("date").size()
                    || parseMap.containsKey("relative_date_span")
                    || parseMap.containsKey("day_of_week")) {
                storageOfDate.add(date);
                setDatePosition(position, matchingValue);
            }

            if ((parseMap.containsKey("explicit_time") && i + 1 <= parseMap
                    .get("explicit_time").size())
                    || parseMap.containsKey("relative_time_span")) {
                storageOfTime.add(time);
                setTimePosition(position, matchingValue);
            }
        }
    }

    /**
     * parse the date and time
     * 
     * @param groups
     *            : contains the date and time in format : <weekday> <month in
     *            word> <day> <HH:mm:ss> <timezone> <year>
     * @param userInput
     *            : contain the user input
     * @return dates: store all of the detected date and time in it
     */
    private void parseDateAndTime(List<DateGroup> groups, String userInput) {
        List<Date> dates = null;
        for (DateGroup group : groups) {
            dates = (group.getDates());

            String matchingValue = group.getText();

            // String syntaxTree = group.getSyntaxTree().toStringTree();
            Map<String, List<ParseLocation>> parseMap = group
                    .getParseLocations();

            int position = getPosition(userInput, matchingValue);

            assert position != -1 : " can't exact text "
                    + "detect in user input.";

            userInputLeftAfterParsing = remove(matchingValue,
                    userInputLeftAfterParsing);

            // so as not to detect the 10 in run 10 rounds
            if (!isNumeric(matchingValue) && !matchingValue.equals("eve")) {
                description = remove(matchingValue, description);

                changeDateFormat(dates, parseMap, matchingValue, position);
            }
        }
    }

    private String remove(String matchingValue, String text) {
        text = text.trim();
        matchingValue = matchingValue.replaceAll("\\s+", " ");
        String[] partOfMatchingValue = matchingValue.split(" ");

        for (int i = 0; i < partOfMatchingValue.length; i++) {
            text = text.replaceFirst(partOfMatchingValue[i], "");
        }
        return text;
    }

    /**
     * 1) test 24 hour format.(HHMM <hour, hours, hr, hrs)
     * 
     * @param userInputLeft
     * @throws : IllegalArgumentException : hour exceed 23 and min exceed 59
     */
    private void testValidTime(String userInputLeft)
            throws IllegalArgumentException {
        try {
            Pattern timeDetector = Pattern.compile(HOUR_FORMAT_KEYWORD);
            Matcher containTime = timeDetector.matcher(userInputLeft);

            while (containTime.find()) {
                Parser dateTimeParser = new Parser();
                if (dateTimeParser.parse(userInputLeft).isEmpty()) {
                    throw new IllegalArgumentException(
                            "24-hour time is invalid!");
                }
            }
        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * test 1. day exceed max day of that month 2) month out of range
     * 
     * @param leftOverUserInput
     * @throws IllegalArgumentException
     *             : month or day out of range
     */
    private void testValidDate(String leftOverUserInput)
            throws IllegalArgumentException {

        Pattern dateDetector = Pattern.compile(MONNTHINWORD_DD_YYYY_KEYWORD);
        Matcher containDate = dateDetector.matcher(leftOverUserInput);

        while (containDate.find()) {
            String date = containDate.group();

            testEmptyGroupAfterParse(date);

            int month = MonthParser.convertMonthToNumber(date);

            int day = NumberParser.getNumber(date);

            if(day == 0){
                break;
            }
            
            int year = YearParser.getYear(date);

            testValidMonth(month);
            testValidDay(day, year, month);

        }
    }

    /**
     * if the group is empty after parse means that the date exceed the max day
     * that mean or the month is out of range (1-12)
     * 
     * @param leftOverUserInput
     * @throws IllegalArgumentException
     *             : month or max day exceeded
     */
    private void testEmptyGroupAfterParse(String leftOverUserInput)
            throws IllegalArgumentException {
        try {
            Parser dateTimeParser = new Parser();
            if (dateTimeParser.parse(leftOverUserInput).isEmpty()) {
                throw new IllegalArgumentException("Date key is invalid!");
            }
        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * throws and catch exception of invalid month
     * 
     * @param month
     * @throws IllegalArgumentException
     *             : month entered out of range
     */
    private void testValidMonth(int month) throws IllegalArgumentException {
        try {
            if (month == 0) {
                throw new IllegalArgumentException("Invalid Month Keyed!");
            }
        } catch (IllegalArgumentException e) {

            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * check if the date is valid if the year and the month have this day For
     * example feb only have max 29 days
     * 
     * @param day
     * @throws IllegalArgumentException
     *             : when day keyed exceed the max day
     */
    private void testValidDay(int day, int year, int month)
            throws IllegalArgumentException {
        try {
            Calendar calendar = Calendar.getInstance();

            if (year != 0) {
                calendar.set(Calendar.YEAR, year);
            }
            calendar.set(Calendar.MONTH, month - 1);

            int maxDays = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

            if (day == 0 || maxDays < day) {
                throw new IllegalArgumentException(
                        "Invalid Day Keyed! Exceed the maximum day in that month");
            }

        } catch (IllegalArgumentException e) {

            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * get the position
     * 
     * @param userInput
     * @param matchingValue
     * @return
     */
    private int getPosition(String userInput, String matchingValue) {
        matchingValue = matchingValue.replaceAll("\\s+", " ");
        matchingValue = matchingValue.trim();
        String[] partOfMatchingValue = matchingValue.split(" ");

        return userInput.indexOf(partOfMatchingValue[0]);

    }

    /**
     * set the start and end date in the right position in arrayList
     *
     * @param indexMatch
     *            : index of the current one
     */
    private void setDatePosition(int indexMatch, String matchingValue) {

        if (storageOfDate.size() == 2
                && (indexMatch < indexDate || matchingValue.contains("now"))) {
           
            String tempForDate = storageOfDate.get(0);          
            storageOfDate.set(0, storageOfDate.get(1));
            storageOfDate.set(1, tempForDate);
            
            indexDate = indexMatch;
        }

    }

    /**
     * set the start and end time in the right position in arrayList
     *
     * @param indexMatch
     *            : index of the current one
     */
    private void setTimePosition(int indexMatch, String matchingValue) {

        if (storageOfTime.size() == 2 && indexMatch < indexTime) {
           
            String tempForTime = storageOfTime.get(0);
            storageOfTime.set(0, storageOfTime.get(1));
            storageOfTime.set(1, tempForTime);
            
            indexTime = indexMatch;

        }
    }

    private boolean isNumeric(String matchingValue) {
        boolean isNumeric = false;
        matchingValue = matchingValue.replaceAll("\\s+", " ");
        matchingValue = matchingValue.trim();
        String[] partOfMatchingValue = matchingValue.split(" ");

        Pattern numberDectector = Pattern.compile("\\b\\d+\\b");
        Matcher matchedWithNumber = numberDectector
                .matcher(partOfMatchingValue[0]);

        if (matchedWithNumber.find()) {
            matchingValue = matchingValue.replaceAll(matchedWithNumber.group(),
                    "");
            if ((matchingValue.length() == 0 && partOfMatchingValue.length == 1)
                    || (partOfMatchingValue.length == 2 && isEqualToMeridiem(partOfMatchingValue))) {
                isNumeric = true;
            }
        }

        return isNumeric;
    }

    /**
     * natty could detect <digit> a from "tutorial 11 preparation today" thus
     * must bypass it
     * 
     * @param partOfMatchingValue
     * @return
     */
    private boolean isEqualToMeridiem(String[] partOfMatchingValue) {
        return partOfMatchingValue[1].equals("a")
                || partOfMatchingValue[1].equals("p")
                || partOfMatchingValue[1].equals("am")
                || partOfMatchingValue[1].equals("pm")
                || partOfMatchingValue[1].equals("a.m.")
                || partOfMatchingValue[1].equals("p.m.");
    }

    /**
     * convert the time to string format(HH:MM)
     * 
     * @param dates
     *            in the format of date and <weekday> <month in word> <day>
     *            <hh:mm:ss> <timezone> <year>
     * @return the Time in string format of <hh:mm>
     */
    private String getTime(Date dates) {
        SimpleDateFormat newDateFormat = new SimpleDateFormat(
                "EEE MMM dd HH:mm:ss z yyyy");

        newDateFormat.applyPattern("HH:mm");
        String time = newDateFormat.format(dates);

        return time;
    }

    /**
     * convert the date to string format <weekday> <day/month/year>
     * 
     * @param dates
     *            : in the format of date and <weekday> <month in word> <day>
     *            <hh:mm:ss> <timezone> <year>
     * @return the Time in string format of <weekday> <day/month/year>
     * 
     */
    private String getDate(Date dates) {
        SimpleDateFormat newDateFormat = new SimpleDateFormat(
                "EEE MMM dd HH:mm:ss z yyyy");

        newDateFormat.applyPattern("dd/MM/yyyy");
        String date = newDateFormat.format(dates);

        return date;
    }

}

	// End of segment: E:\main\src\parser\DateTimeNattyParser.java





	/**
	 * origin: E:\main\src\parser\DateTimeNattyParserDateOnlyTest.java
	 */

 *
 */
public class DateTimeNattyParserDateOnlyTest {
    @Test
    // current date : 10/04/2015
    public void test() {

        // test when two date in a input
        ArrayList<String> dates = new ArrayList<String>();
        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "add start reading ST2334 notes by today 8 am tomorrow 2330");
        dates.add("10/04/2015");
        dates.add("11/04/2015");
        assertEquals(dates, dateTime.getDateList());

    }

    @Test
    public void testMMDDYYYY() {

        // mmdd
        ArrayList<String> dates = new ArrayList<String>();
        DateTimeNattyParser dateTime = new DateTimeNattyParser("jan 24");
        dates.add("24/01/2015");
        assertEquals(dates, dateTime.getDateList());

        // mmddyyy
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser("jan 24 2017");
        dates.clear();
        dates.add("24/01/2017");
        assertEquals(dates, dateTime1.getDateList());

        // mm/dd/yyy
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser("2/24/2017");
        dates.clear();
        dates.add("24/02/2017");
        assertEquals(dates, dateTime2.getDateList());

    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date + number of days Current date
     * : 10/04/2015
     */
    public void daysApartKeywordTest() {
        ArrayList<String> dates = new ArrayList<String>();
        // test keyword 4: 3 _ days ago
        dates.clear();
        dates.add("07/04/2015");
        DateTimeNattyParser dateTime12 = new DateTimeNattyParser(
                "mds sale 3 days ago");
        assertEquals(dates, dateTime12.getDateList());

        // test keyword 4: next _ days
        dates.clear();
        dates.add("10/04/2015");
        dates.add("14/04/2015");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "mds sale start in next 4 days");
        assertEquals(dates, dateTime1.getDateList());

        // test keyword 4: _ days from now
        dates.clear();
        dates.add("15/04/2015");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "mds sale start 5 day from now");
        assertEquals(dates, dateTime2.getDateList());

        // test keyword 4: in __day times
        dates.clear();
        dates.add("15/04/2015");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "mds sale start in 5 days time");
        assertEquals(dates, dateTime3.getDateList());

        // test keyword 4: _ days after (in word form)
        dates.clear();
        dates.add("13/04/2015");
        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "mds sale start in three days after");
        assertEquals(dates, dateTime5.getDateList());

    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date + number of days Interpret by
     * the vocab
     */
    public void testDaysApartVocabKeyword() {
        ArrayList<String> dates = new ArrayList<String>();
        // test keyword 5: tomorrow
        dates.clear();
        dates.add("11/04/2015");
        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "mds sale from tomorrow");
        assertEquals(dates, dateTime.getDateList());

        // test keyword 5: the next day
        dates.clear();
        dates.add("11/04/2015");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "mds sale the next day");
        assertEquals(dates, dateTime1.getDateList());

        // the day before
        dates.clear();
        dates.add("14/03/2016");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "mds sale six day before   03/20/2016  mds sale  ");
        assertEquals(dates, dateTime2.getDateList());

        // the monday before
        dates.clear();
        dates.add("11/01/2015");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "mds sale six monday before before 11 Jan");
        assertEquals(dates, dateTime3.getDateList());

        // the tues after
        dates.clear();
        dates.add("07/04/2015");
        DateTimeNattyParser dateTime4 = new DateTimeNattyParser(
                "mds sale 1 tues after 4/4");
        assertEquals(dates, dateTime4.getDateList());

        // the day after
        dates.clear();
        dates.add("11/04/2015");

        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "mds sale seven day after 4 Apr");
        assertEquals(dates, dateTime5.getDateList());

    }

    @Test
    public void testDateAlternatives() {
        ArrayList<String> dates = new ArrayList<String>();

        // next wed or thru
        dates.clear();
        dates.add("17/04/2015");
        dates.add("12/04/2015");

        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "mds sale next friday or sunday");
        assertEquals(dates, dateTime5.getDateList());

        // next wed and thru
        dates.clear();
        dates.add("18/04/2015");
        dates.add("12/04/2015");

        DateTimeNattyParser dateTime6 = new DateTimeNattyParser(
                "mds sale next sat and sunday");
        assertEquals(dates, dateTime6.getDateList());

        // date and date
        dates.clear();
        dates.add("24/01/2015");
        dates.add("25/01/2015");

        DateTimeNattyParser dateTime7 = new DateTimeNattyParser(
                "mds sale jan 24 and jan 25");
        assertEquals(dates, dateTime7.getDateList());

        // date or date
        dates.clear();
        dates.add("10/01/2015");
        dates.add("14/01/2015");

        DateTimeNattyParser dateTime8 = new DateTimeNattyParser(
                "mds sale jan 10 or jan 14");
        assertEquals(dates, dateTime8.getDateList());

    }

    @Test
    /*
     * do take note that I use current date extract from laptop Thus, the date
     * result from date parser is the current date + number of week/month/year
     * Interpret by the vocab Current date : 10/4/2015
     */
    public void testWeekMonthYearApartKeyword() {
        ArrayList<String> dates = new ArrayList<String>();

        // test keyword 6: next __month
        dates.clear();
        dates.add("10/04/2015");
        dates.add("10/05/2015");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "mds sale start next 1 months ");
        assertEquals(dates, dateTime1.getDateList());

        // test keyword 6 : in __ weeks times
        dates.clear();
        dates.add("17/04/2015");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "mds sale in 1 week time");
        assertEquals(dates, dateTime3.getDateList());

        // test keyword 6 : __ weeks from now on
        dates.clear();
        dates.add("10/04/2015");
        dates.add("17/04/2015");
        DateTimeNattyParser dateTime4 = new DateTimeNattyParser(
                "mds sale in 1 week from now on");
        assertEquals(dates, dateTime4.getDateList());

        // test keyword 4: 3 _ weeks ago
        dates.clear();
        dates.add("20/03/2015");
        DateTimeNattyParser dateTime16 = new DateTimeNattyParser(
                "mds sale 3 weeks ago");
        assertEquals(dates, dateTime16.getDateList());

        // test keyword 6: after __month
        dates.clear();
        dates.add("10/05/2015");
        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "mds sale start after 1 month");
        assertEquals(dates, dateTime5.getDateList());

        // test keyword 6: in __month from now on
        dates.clear();
        dates.add("10/04/2015");
        dates.add("10/05/2015");
        DateTimeNattyParser dateTime6 = new DateTimeNattyParser(
                "mds sale in 1 month from now on");
        assertEquals(dates, dateTime6.getDateList());

        // test keyword 6: start __month from now on
        dates.clear();
        dates.add("01/05/2015");
        DateTimeNattyParser dateTime7 = new DateTimeNattyParser(
                "mds sale start start 1 month from now on");
        assertEquals(dates, dateTime7.getDateList());

        // test keyword 6: in __month times
        dates.clear();
        dates.add("10/05/2015");
        DateTimeNattyParser dateTime15 = new DateTimeNattyParser(
                "mds sale start in 1 month time");
        assertEquals(dates, dateTime15.getDateList());

        // test keyword 6: next __month
        dates.clear();
        dates.add("10/04/2015");
        dates.add("10/05/2015");
        DateTimeNattyParser dateTime8 = new DateTimeNattyParser(
                "mds sale start next 1 month");
        assertEquals(dates, dateTime8.getDateList());

        // test keyword 4: 3 _ month ago
        dates.clear();
        dates.add("10/01/2015");
        DateTimeNattyParser dateTime18 = new DateTimeNattyParser(
                "mds sale 3 month ago");
        assertEquals(dates, dateTime18.getDateList());

        // test the rest of aliases in __ year times
        dates.clear();
        dates.add("10/04/2018");
        DateTimeNattyParser dateTime11 = new DateTimeNattyParser(
                "mds sale start in 3 year times");
        assertEquals(dates, dateTime11.getDateList());

        // test the rest of aliases next __ year
        dates.clear();
        dates.add("10/04/2015");
        dates.add("10/04/2018");
        DateTimeNattyParser dateTime12 = new DateTimeNattyParser(
                "mds sale start next 3 year");
        assertEquals(dates, dateTime12.getDateList());

        // test the rest of aliases __ year in .... from now on
        dates.clear();
        dates.add("10/04/2015");
        dates.add("10/04/2018");
        DateTimeNattyParser dateTime13 = new DateTimeNattyParser(
                "mds sale in 3 year from now on");
        assertEquals(dates, dateTime13.getDateList());

        // test keyword 4: _ years ago
        dates.clear();
        dates.add("10/04/2012");
        DateTimeNattyParser dateTime17 = new DateTimeNattyParser(
                "mds sale 3 year ago");
        assertEquals(dates, dateTime17.getDateList());

        // test the word format of number
        dates.clear();
        dates.add("10/04/2018");
        DateTimeNattyParser dateTime14 = new DateTimeNattyParser(
                "mds sale start three year from now on");
        assertEquals(dates, dateTime14.getDateList());
    }

    public void MonthInWordDDTest() {
        ArrayList<String> dates = new ArrayList<String>();

        // test without year
        dates.clear();
        dates.add("10/04/2015");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "Today is april 10");
        assertEquals(dates, dateTime2.getDateList());

        // test with year
        dates.clear();
        dates.add("10/04/2015");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "Today is april 10 2015");
        assertEquals(dates, dateTime3.getDateList());

        // test all of the date in word
        dates.clear();
        dates.add("05/04/2015");
        DateTimeNattyParser dateTime4 = new DateTimeNattyParser(
                "just joking, today is five april 2015");
        assertEquals(dates, dateTime4.getDateList());

        // test date that is in mm/dd/yyyy all in word
        dates.clear();
        dates.add("20/05/2015");
        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "is it april fool day,  may 20 2015");
        assertEquals(dates, dateTime5.getDateList());

    }

    @Test
    public void testComplication() {
        ArrayList<String> dates = new ArrayList<String>();
        // natty detect this as 11 a
        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "Tutorial 11 preparation by");
        assertEquals(dates, dateTime5.getTimeList());

        // natty detect this as 11 p
        DateTimeNattyParser dateTime6 = new DateTimeNattyParser(
                "Tutorial 11 p by");
        assertEquals(dates, dateTime6.getTimeList());

        // natty detect this as 11 p
        DateTimeNattyParser dateTime7 = new DateTimeNattyParser(
                "run 11 round by");
        assertEquals(dates, dateTime7.getTimeList());
    }

}

// notes:
// 1. can't detect 25/03 or 25/03/2015
// 2. don noe which is the start and end date and time.
// 3. 8am-9 does not work
// 4. time past current time does not set it to next day
// 5. 8-9am does not work
// 6. 7 at night to 3 in the morn 2nd of may --> the 2nd of may ==> infinite
// loop
// 7. can't detect 3 in morn/ 3 in morning
// 8.morning 2nd of may --> 8:00 02/May/2015
// 9. can't detect tmr
// 10. can't detect OcToBor
// 11. can't detect the following day
// 12. after tomorrow --> detect as tomorrow
// 13. after today --> detect as today
// 14. can't detect past midnight/before midnight/past noon/ past noon
// 15. can't detect ..... later
// 16. can only have 2 dates: IN ___ days from now
// 17: start in three days ago --> become three day later (only work 3 day ago)
// 18. 6 - 6pm -- > result 18:00, 18:00
// 19. 1pm - 6 --> 6 is in the morning


	// End of segment: E:\main\src\parser\DateTimeNattyParserDateOnlyTest.java





	/**
	 * origin: E:\main\src\parser\DateTimeNattyParserTimeOnlyTest.java
	 */

 *
 */
public class DateTimeNattyParserTimeOnlyTest {

    @Test
    public void test() {

    }

    @Test
    /**
     * test without escaped char
     */
    public void testTimeNULL() {
        ArrayList<String> times = new ArrayList<String>();

        // test when nothing is detected
        times.clear();
        DateTimeNattyParser dateTime = new DateTimeNattyParser("");
        assertEquals(times, dateTime.getTimeList());

    }

    @Test
    public void testMidnightOrNoonKeyword() {
        // test midnight
        ArrayList<String> times = new ArrayList<String>();

        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "mds sale start midnight");

        times.add("00:00");
        assertEquals(times, dateTime.getTimeList());

        // test noon
        times.clear();
        times.add("12:00");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser("noon run");
        assertEquals(times, dateTime1.getTimeList());

        // test afternoon
        times.clear();
        times.add("12:00");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser("afternoon run");
        assertEquals(times, dateTime2.getTimeList());

        // test morning
        times.clear();
        times.add("08:00");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser("morning run");
        assertEquals(times, dateTime3.getTimeList());

    }

    @Test
    // take note of current time, change the result according
    // current time : 22:17
    public void testHoursApart() {
        // test current time + 2 hours
        ArrayList<String> times = new ArrayList<String>();

        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "mds sale for 2 hours");
        times.add("22:17");
        times.add("00:17");
        assertEquals(times, dateTime.getTimeList());

        // test current time + 2 hours

        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "mds sale for 2 hrs");
        times.clear();
        times.add("22:17");
        times.add("00:17");
        assertEquals(times, dateTime1.getTimeList());

        // test with hr
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "mds sale for 1 hr");
        times.clear();
        times.add("22:17");
        times.add("23:17");
        assertEquals(times, dateTime2.getTimeList());

        // test with hour
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "mds sale for 1 hour");
        times.clear();
        times.add("22:17");
        times.add("23:17");
        assertEquals(times, dateTime3.getTimeList());

    }

    @Test
    /**
     * test twenty hour format(HH:MM) without the punctuation between
     * hour and minute and with or without hour or hr or hrs or hours behind it. 
     */
    public void test24HourWithoutPunc() {
        ArrayList<String> times1 = new ArrayList<String>();

        // test with hrs
        times1.clear();
        times1.add("11:00");
        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "mds sale start at 1100 hrs");
        assertEquals(times1, dateTime.getTimeList());

        // test with hr
        times1.clear();
        times1.add("12:00");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "mds sale start at 1200 hr");
        assertEquals(times1, dateTime1.getTimeList());

        // test with hour
        times1.clear();
        times1.add("15:00");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "mds sale start at 1500 hour");
        assertEquals(times1, dateTime2.getTimeList());

        // test with hours
        times1.clear();
        times1.add("16:00");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "mds sale start at 1600 hours");
        assertEquals(times1, dateTime3.getTimeList());
    }

    @Test
    /**
     * take note testing this follow the current time of their laptop
     * change the test result according.
     * When i test it, current time: 9:44pm
     */
    public void testRelativeTime() {
        ArrayList<String> times = new ArrayList<String>();
        // test _ seconds ago
        times.clear();
        times.add("21:43");
        DateTimeNattyParser dateTime = new DateTimeNattyParser(
                "10 seconds ago, gigi bark!");
        assertEquals(times, dateTime.getTimeList());

        // test _ minutes ago
        times.clear();
        times.add("21:13");
        DateTimeNattyParser dateTime1 = new DateTimeNattyParser(
                "30 min ago, gigi bark!");
        assertEquals(times, dateTime1.getTimeList());

        // test _ hours ago
        times.clear();
        times.add("20:44");
        DateTimeNattyParser dateTime2 = new DateTimeNattyParser(
                "One hour ago, gigi bark!");
        assertEquals(times, dateTime2.getTimeList());

        // test in 5 minutes
        times.clear();
        times.add("21:49");
        DateTimeNattyParser dateTime3 = new DateTimeNattyParser(
                "gigi sleep in 5 minutes");
        assertEquals(times, dateTime3.getTimeList());

        // test in 5 hours
        times.clear();
        times.add("00:44");
        DateTimeNattyParser dateTime4 = new DateTimeNattyParser(
                "gigi sleep in 3 hours");
        assertEquals(times, dateTime4.getTimeList());

        // test in 5 second
        times.clear();
        times.add("21:44");
        DateTimeNattyParser dateTime5 = new DateTimeNattyParser(
                "gigi sleep in 1 second");
        assertEquals(times, dateTime5.getTimeList());

        // test in 4 minutes from now
        times.clear();
        times.add("21:50");
        DateTimeNattyParser dateTime6 = new DateTimeNattyParser(
                "runrun 4 minutes from now");
        assertEquals(times, dateTime6.getTimeList());

        // test in 4 hour from now
        times.clear();
        times.add("01:45");
        DateTimeNattyParser dateTime7 = new DateTimeNattyParser(
                "runrun 4 hour from now");
        assertEquals(times, dateTime7.getTimeList());

        // test in four hour from now
        times.clear();
        times.add("01:45");
        DateTimeNattyParser dateTime8 = new DateTimeNattyParser(
                "runrun four hour from now");
        assertEquals(times, dateTime8.getTimeList());

    }
}
	// End of segment: E:\main\src\parser\DateTimeNattyParserTimeOnlyTest.java





	/**
	 * origin: E:\main\src\parser\DateTimeParser.java
	 */

 *
 */
public class DateTimeParser {
    private static final String DATE_FORMAT = "dd/MM/yyyy";
    private static final String TIME_FORMAT = "HH:mm";
    private int numberOfTime;
    private String fullUserInput;
    private String description;
    private String feedback;
    private String startTime = "-", endTime = "-", startDate = "-",
            endDate = "-";
    private final String BEFORE_AFTER_MMDD_KEYWORD = "\\b(\\w+(\\s|)(day(s|)|the day(s|)"
            + "|(mon|tues|wed|thurs|fri|sat|sun)(day|nesday|urday|)(s|))"
            + "( before| after)) ((\\d+([/.]\\d+[/.-]\\d+|[/.-]\\d+)\\b)|((\\w+|)(-|)\\w+(th|nd|rd|st|)(\\s|\\S)(of |)(january|febuary|march|april|may|june|july|august"
            + "|september|octobor|november|december)(\\s|)((in (the|) (year|yr)(s|))|)(\\s|)(\\d+|))|(\\w+|)(-|)\\w+(th|nd|rd|st|)(\\s|\\S)(of |)(jan|feb|mar|apr|may|jun|jul|aug"
            + "|sep|oct|nov|dec)(\\s|\\S)((in (the|) (year|yr)(s|))|)(\\s|)(\\d+|))";
    private final String NEXT_WEEKDAY_AND_OR = "(\\b(next|this|at|by|due on|on|due) (mon|tues|wed|thurs|fri|sat|sun)(day|nesday|urday|)(s|) (or|and) "
            + "(mon|tues|wed|thurs|fri|sat|sun)(day|nesday|urday|)(s|)\\b)";
    private ArrayList<String> storageOfTime = new ArrayList<String>();
    private ArrayList<String> storageOfDate = new ArrayList<String>();

    public DateTimeParser(String userInput) throws Exception {
        fullUserInput = userInput;
        TimeParser times = extractFromTimeParser();
        int indexPrevTime = times.getPosition();

        String leftOverInput;
        DateParser dates = extractFromDateParser(times);
        int indexPrevDate = dates.getIndex();

        leftOverInput = getLeftOverInput(dates);

        extractFromNattyParser(indexPrevTime, leftOverInput, indexPrevDate);

        assert storageOfDate.size() <= 2 : "key in more than 2 dates!";
        assert storageOfTime.size() <= 2 : "key in more than 2 times!";

        testForExceptionCases(storageOfTime, storageOfDate);

        storageOfTime = addInMissingTime(storageOfTime, storageOfDate);
        storageOfDate = addInMissingDate(storageOfTime, storageOfDate);

        addWeekDayToDate(storageOfDate);
        setNumberOfTime(storageOfTime);
        setAllParameters(storageOfTime, storageOfDate);
    }

    private void extractFromNattyParser(int indexPrevTime,
            String leftOverInput, int indexPrevDate) {

        DateTimeNattyParser dateTimeNatty = new DateTimeNattyParser();
        dateTimeNatty.extractDateTime(fullUserInput, leftOverInput,
                storageOfDate, storageOfTime, indexPrevTime, indexPrevDate);

        storageOfTime = dateTimeNatty.getTimeList();
        storageOfDate = dateTimeNatty.getDateList();
        description = dateTimeNatty.getDescription();
    }

    private TimeParser extractFromTimeParser() throws Exception {

        TimeParser times = new TimeParser(fullUserInput);
        storageOfTime = times.getTimeList();

        return times;
    }

    private DateParser extractFromDateParser(TimeParser times) {
        DateParser dates = new DateParser();
        String leftOverInput = removeComplication(times.getInputLeft());
        dates.extractDate(fullUserInput, leftOverInput);
        storageOfDate = dates.getDateList();

        return dates;
    }

    /**
     * to prevent case sensitive, switch all to lower case
     * 
     * @param userInput
     * @return the user input all in lower case.
     */
    private String switchAllToLowerCase(String userInput) {
        userInput = userInput.replaceAll("\\s+", " ");
        userInput = " " + userInput.toLowerCase() + " ";
        return userInput;
    }

    /**
     * make changes to the userInput, so that it will bypass detection from
     * dateParser and detect by natty which could only detect correctly by natty
     * 
     * @param dates
     * @return userInput
     */
    private String getLeftOverInput(DateParser dates) {
        fullUserInput = switchAllToLowerCase(fullUserInput);
        String leftOverInput = convertDDMMToMMDD(dates.getInputLeft());
        leftOverInput = getRemovedKeyword(leftOverInput);
        return leftOverInput;
    }

    /**
     * add back the removal keyword that will detect by Date1Parser but only
     * natty could parse it correctly
     * 
     * @param userInput
     * @param leftOverInput
     * @return leftOverInput only for natty to detect
     */
    private String getRemovedKeyword(String leftOverInput) {
        Pattern detector = Pattern.compile(NEXT_WEEKDAY_AND_OR);
        Matcher containComplicationWord = detector.matcher(fullUserInput);

        while (containComplicationWord.find()) {
            String word = "";
            word = containComplicationWord.group();
            leftOverInput = leftOverInput + " " + word;
        }

        return leftOverInput;
    }

    /**
     * so that the natty could detect correctly
     * 
     * @param userInput
     * @param inputLeft
     * @return userInput for natty to detect
     */
    private String convertDDMMToMMDD(String inputLeft) {
        Pattern detector = Pattern.compile(BEFORE_AFTER_MMDD_KEYWORD);
        Matcher containComplicationWord = detector.matcher(fullUserInput);

        while (containComplicationWord.find()) {

            String word = containComplicationWord.group();
            DateParser dateParser = new DateParser(word);
            ArrayList<String> date = dateParser.getDateList();

            assert date.size() == 1 : "only should have one date detected!";

            String[] partOfDate = date.get(0).split("/");

            assert partOfDate.length == 3 : "Detected date should be in a format of dd/mm/yyyy";

            String wordWithoutDate = dateParser.getInputLeft();

            fullUserInput = fullUserInput.replaceAll(word, wordWithoutDate
                    + " " + partOfDate[1] + "/" + partOfDate[0] + "/"
                    + partOfDate[2]);

            inputLeft = inputLeft + wordWithoutDate + " " + partOfDate[1] + "/"
                    + partOfDate[0] + "/" + partOfDate[2];
        }
        return inputLeft;
    }

    /**
     * remove complication like those will detect in Date1Parser but only could
     * be detect correctly in natty. So we remove them 1st.
     * 
     * @param userInput
     * @return userInput after removal
     */
    private String removeComplication(String userInput) {

        userInput = removeBeforeAfterDateKeyowrd(userInput);

        userInput = removeNextWeekAndOrWeekKeyword(userInput);

        return userInput;
    }

    /**
     * remove keyword of next <weekday> and/or <weekday>
     * 
     * @param userInput
     * @return the userinput after removal.
     */
    private String removeNextWeekAndOrWeekKeyword(String userInput) {
        Pattern detector = Pattern.compile(NEXT_WEEKDAY_AND_OR);
        Matcher containComplicationWord = detector.matcher(userInput);

        while (containComplicationWord.find()) {
            String word = "";
            word = containComplicationWord.group();
            userInput = userInput.replaceAll(word, "");
        }

        return userInput;
    }

    /**
     * remove keyword of _____ before/after date
     * 
     * @param userInput
     * @return userInput after removal
     */
    private String removeBeforeAfterDateKeyowrd(String userInput) {

        Pattern detector = Pattern.compile(BEFORE_AFTER_MMDD_KEYWORD);
        Matcher containComplicationWord = detector.matcher(userInput);

        while (containComplicationWord.find()) {
            String word = "";
            word = containComplicationWord.group();
            userInput = userInput.replaceAll(word, "");
        }
        return userInput;
    }

    /**
     * get the feedback for overdue date like start date or time keyed is before
     * current date but end time and date
     * 
     * @return feedback for overdue date to logic
     */
    public String getFeedBack() {
        return feedback;
    }

    /**
     * add weekday to the start of the date into <weekDay> dd/mm/yyyy
     * 
     * @param storageOfDate
     *            :contains date in dd/mm/yyyy
     */
    private void addWeekDayToDate(ArrayList<String> storageOfDate) {

        for (int i = 0; i < storageOfDate.size(); i++) {
            if (storageOfDate.get(i).substring(0, 1).matches("\\d")) {
                String weekDay = WeekDayParser.getWeekDay(storageOfDate.get(i));
                storageOfDate.set(i, weekDay + " " + storageOfDate.get(i));
            }
        }

    }

    /**
     * set all parameters : start time and date, end time and date, deadline
     * time and deadline time
     * 
     * @param storageOfTime
     *            : contains all time
     * @param storageOfDate
     *            contains all date
     */
    private void setAllParameters(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) {

        setAllParametersToDash();
        if (storageOfTime.size() == 1) {

            setStartTime("-");
            setEndTime(storageOfTime.get(0));

            setStartDate("-");
            setEndDate(storageOfDate.get(0));

        } else if (storageOfTime.size() == 2) {

            setStartTime(storageOfTime.get(0));
            setEndTime(storageOfTime.get(1));

            setStartDate(storageOfDate.get(0));
            setEndDate(storageOfDate.get(1));
        }
    }

    /**
     * 1) Key in same times and same dates --> don't allow user to add 2) Key in
     * time before current time on current date 3) Key in date later than
     * current date --> remind the user meeting have pass. 4) key in start time
     * before current time but end time after current time --> remind the user
     * meeting is ongoing.
     * 
     * @param storageOfTime
     * @param storageOfDate
     */
    private void testForExceptionCases(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws Exception {

        checkDateBeforeCurrent(storageOfTime, storageOfDate);
        checkOngoingTimeTask(storageOfDate, storageOfTime);
        checkImpossibleTimedTask(storageOfTime, storageOfDate);

    }

    /**
     * check impossible combination of time task For example, same day with two
     * same date keyed by user
     * 
     * @param storageOfTime
     *            : time contained all time detected
     * @param storageOfDate
     *            : date contined all date detected
     * @throws ParseException
     *             : fail to parse date
     * @throws IllegalArgumentException
     *             : type in start date later than end date
     * 
     */
    private void checkImpossibleTimedTask(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {
        Logger logger = Logger.getLogger("DateTimeParser");
        try {
            logger.log(Level.INFO,
                    "going to start processing for impossible time task keyed");
            checkStartDateLaterWhenBothKeyed(storageOfTime, storageOfDate);
            checkStartDateLaterWhenTimeNotKeyed(storageOfDate);

        } catch (IllegalArgumentException e) {
            logger.log(Level.WARNING, "processing error", e);
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());

        }
    }

    /**
     * check that on same day is start time is later than end and same time and
     * same date. if yes, throw IllegalArgumentException
     * 
     * @param storageOfTime
     * @param storageOfDate
     * @throws ParseException
     *             : fail to parse date
     * @throws IllegalArgumentException
     *             : type in start date later than end date
     */
    private void checkStartDateLaterWhenBothKeyed(
            ArrayList<String> storageOfTime, ArrayList<String> storageOfDate)
            throws ParseException {
        if (storageOfTime.size() == 2 && storageOfDate.size() == 2) {

            SimpleDateFormat dateFormat = new SimpleDateFormat(
                    "dd/MM/YYYY HH:mm");
            Date startDate = dateFormat.parse(storageOfDate.get(0) + " "
                    + storageOfTime.get(0));
            Date endDate = dateFormat.parse(storageOfDate.get(1) + " "
                    + storageOfTime.get(1));

            if (startDate.after(endDate) || startDate.equals(endDate)) {
                throw new IllegalArgumentException(
                        "Impossible combination for timed task! End time must be later than start time on the same day");
            }
        }
    }

    /**
     * check that start date later than end date, if yes, throws
     * IllegalArgumentException
     * 
     * @param storageOfDate
     * @throws ParseException
     *             : fail to parse date
     * @throws IllegalArgumentException
     *             : type in start date later than end date
     */
    private void checkStartDateLaterWhenTimeNotKeyed(
            ArrayList<String> storageOfDate) throws ParseException {
        if (storageOfDate.size() == 2) {
            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
            Date date1 = dateFormat.parse(storageOfDate.get(0));
            Date date2 = dateFormat.parse(storageOfDate.get(1));

            if (date1.after(date2)) {
                throw new IllegalArgumentException(
                        "Impossible combination for timed task! End date must be later than start date");
            }
        }
    }

    /**
     * check 1) user key in overdue time that before current time 2) user key in
     * date before current date
     * 
     * @param storageOfTime
     *            : contains time detected
     * @param storageOfDate
     *            : contains date detected
     * @throws ParseException
     *             : fail to parse date
     */
    private void checkDateBeforeCurrent(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {

        overdueTaskDueToTime(storageOfTime, storageOfDate);

        overdueTaskDueToDate(storageOfDate);

    }

    private void overdueTaskDueToTime(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {
        if (storageOfTime.size() > 0) {

            int numberBeforeCurrentTime = countNumberBeforeCurrentTime(storageOfTime);

            if (storageOfTime.size() == 1
                    && numberBeforeCurrentTime == 1
                    && (storageOfDate.size() == 1 && storageOfDate.get(0)
                            .equals(getCurrentDate()))) {

                feedback = "Time keyed past the current time!!";
                JOptionPane.showMessageDialog(null,
                        "Time keyed past the current time!!", "REMAINDER",
                        JOptionPane.INFORMATION_MESSAGE);

            } else if ((storageOfDate.size() == 2
                    && numberBeforeCurrentTime == 2
                    && storageOfDate.get(0).equals(getCurrentDate()) && storageOfDate
                    .get(1).equals(getCurrentDate()))) {

                feedback = "Time keyed past the current time!!";
                JOptionPane.showMessageDialog(null,
                        "Time keyed past the current time!!", "REMAINDER",
                        JOptionPane.INFORMATION_MESSAGE);

            }
        }
    }

    private void overdueTaskDueToDate(ArrayList<String> storageOfDate)
            throws ParseException {
        if (storageOfDate.size() > 0) {

            int numberBeforeCurrentDate = countNumberBeforeCurrentDate(storageOfDate);

            if (storageOfDate.size() == 1 && numberBeforeCurrentDate == 1) {

                feedback = "Date keyed past the current date!";
                JOptionPane.showMessageDialog(null,
                        "Date keyed past the current date!", "REMAINDER",
                        JOptionPane.INFORMATION_MESSAGE);

            } else if (storageOfDate.size() == 2
                    && numberBeforeCurrentDate == 2) {

                feedback = "Date keyed past the current date!";
                JOptionPane.showMessageDialog(null,
                        "Date keyed past the current date!", "REMAINDER",
                        JOptionPane.INFORMATION_MESSAGE);

            }
        }
    }

    /**
     * check if the start time is before the current time
     * 
     * @param storageOfTime
     *            : contains time detected in user input
     * @return true if the time is before current time otherwise false.
     * @throws ParseException
     *             : fail to parse date
     */
    private boolean isStartTimeBeforeCurrent(ArrayList<String> storageOfTime)
            throws ParseException {
        boolean isStartTimeBeforeCurrent = false;
        if (storageOfTime.size() >= 1) {

            String currentTime = getCurrentTime();

            SimpleDateFormat dateFormat = new SimpleDateFormat(TIME_FORMAT);

            Date time = dateFormat.parse(storageOfTime.get(0));
            Calendar calendarTime = Calendar.getInstance();
            calendarTime.setTime(time);

            Date timeNow = dateFormat.parse(currentTime);
            Calendar calendarOfCurrentTime = Calendar.getInstance();
            calendarOfCurrentTime.setTime(timeNow);

            if (calendarOfCurrentTime.getTime().after(calendarTime.getTime())) {
                isStartTimeBeforeCurrent = true;
            }

        }
        return isStartTimeBeforeCurrent;
    }

    /**
     * calculate the number of time keyed past the current time
     * 
     * @param storageOfDate
     *            : stored time keyed by user in hh:mm format
     * @param numberPastCurrentDate
     *            : store the number that past current time
     * @return number of time keyed past current time
     * @throws ParseException
     *             : fail to parse date
     */
    private int countNumberBeforeCurrentTime(ArrayList<String> storageOfTime)
            throws ParseException {

        int numberBeforeCurrentTime = 0;

        for (int i = 0; i < storageOfTime.size(); i++) {
            String currentTime = getCurrentTime();

            SimpleDateFormat dateFormat = new SimpleDateFormat(TIME_FORMAT);

            Date time = dateFormat.parse(storageOfTime.get(i));
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(time);

            Date timeForNow = dateFormat.parse(currentTime);
            Calendar calendarOfCurrentTime = Calendar.getInstance();
            calendarOfCurrentTime.setTime(timeForNow);

            if (calendarOfCurrentTime.getTime().after(calendar.getTime())) {
                numberBeforeCurrentTime++;
            }

        }

        return numberBeforeCurrentTime;
    }

    /**
     * give remainder user key in task that have start date before current date
     * but end date that is after current date
     * 
     * @param storageOfDate
     *            :contains dates detected
     * @throws ParseException
     *             : fail to parse date
     */
    private void checkOngoingTimeTask(ArrayList<String> storageOfDate,
            ArrayList<String> storageOfTime) throws ParseException {

        checkOngoingDueToDate(storageOfDate, storageOfTime);

        checkOngoingDueToTime(storageOfDate, storageOfTime);
    }

    private void checkOngoingDueToTime(ArrayList<String> storageOfDate,
            ArrayList<String> storageOfTime) throws ParseException {

        boolean isStartTimeBeforeCurrent = isStartTimeBeforeCurrent(storageOfTime);

        if (storageOfTime.size() == 2 && storageOfDate.size() > 0
                && isStartTimeBeforeCurrent
                && storageOfDate.get(0).equals(getCurrentDate())) {

            feedback = "The start date keyed have past the current date but end date have not.\nGo For The Meeting!";

            JOptionPane.showMessageDialog(null,
                    "The start date keyed have past the current date but end date have not.\n"
                            + "Go For The Meeting!", "REMAINDER",
                    JOptionPane.INFORMATION_MESSAGE);

        }
    }

    private void checkOngoingDueToDate(ArrayList<String> storageOfDate,
            ArrayList<String> storageOfTime) throws ParseException {
        int numberBeforeCurrentDate = countNumberBeforeCurrentDate(storageOfDate);

        if ((storageOfDate.size() == 2 || storageOfTime.size() == 2)
                && numberBeforeCurrentDate == 1) {

            feedback = "The start date keyed have past the current date but end date have not.\nGo For The Meeting!";

            JOptionPane.showMessageDialog(null,
                    "The start date keyed have past the current date but end date have not.\n"
                            + "Go For The Meeting!", "REMAINDER",
                    JOptionPane.INFORMATION_MESSAGE);

        }

    }

    /**
     * calculate the number of date keyed past the current date
     * 
     * @param storageOfDate
     *            : stored date keyed by user in <weekday> dd/mm/yyyy format
     * @param numberPastCurrentDate
     *            : store the number that past current date
     * @return number of date keyed past current day
     * @throws ParseException
     *             : fail to parse date
     */
    private int countNumberBeforeCurrentDate(ArrayList<String> storageOfDate)
            throws ParseException {
        int numberBeforeCurrentDate = 0;

        for (int i = 0; i < storageOfDate.size(); i++) {

            SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);

            Date date = dateFormat.parse(storageOfDate.get(i));
            Calendar dateCalendar = Calendar.getInstance();
            dateCalendar.setTime(date);

            Calendar todayCalendar = Calendar.getInstance();
            String currentDate = getCurrentDate();

            Date dateOfToday = dateFormat.parse(currentDate);
            todayCalendar.setTime(dateOfToday);

            if (todayCalendar.getTime().after(dateCalendar.getTime())) {
                numberBeforeCurrentDate++;
            }

        }
        return numberBeforeCurrentDate;
    }

    /**
     * set all the parameters to "-"
     */
    private void setAllParametersToDash() {
        setStartTime("-");
        setEndTime("-");
        setStartDate("-");
        setEndDate("-");
    }

    /**
     * set start date
     * 
     * @param date
     */
    private void setStartDate(String date) {
        startDate = date;
    }

    /**
     * get start date
     * 
     * @return start date for timed task
     */
    public String getStartDate() {
        return startDate;
    }

    /**
     * set the end date
     * 
     * @param date
     */
    private void setEndDate(String date) {
        endDate = date;
    }

    /**
     * get end end
     * 
     * @return end date for timed
     */
    public String getEndDate() {
        return endDate;
    }

    /**
     * set end time
     * 
     * @param time
     */
    private void setEndTime(String time) {
        endTime = time;
    }

    /**
     * get end time
     * 
     * @return end time
     */
    public String getEndTime() {
        return endTime;
    }

    /**
     * set the start time for timed task
     * 
     * @param time
     */
    private void setStartTime(String time) {
        startTime = time;
    }

    /**
     * return start time for timed task
     * 
     * @return start time
     */
    public String getStartTime() {
        return startTime;
    }

    /**
     * add in the time that is not keyed in by the user and by the the right
     * interpreted
     * 
     * @param storageOfTime
     *            :contains all time detected
     * @param storageOfDate
     *            :conatains all date detected
     * @throws ParseException
     */
    private ArrayList<String> addInMissingTime(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {

        if (storageOfTime.size() < storageOfDate.size()) {

            if (storageOfTime.size() == 0 && storageOfDate.size() == 1) {

                storageOfTime.add("23:59");

            } else if (storageOfTime.size() == 0 && storageOfDate.size() == 2) {

                addTimeWhenNoTimeAndTwoDate(storageOfTime, storageOfDate);

            } else if (storageOfTime.size() == 1 && storageOfDate.size() == 2) {

                storageOfTime.add("23:59");

            }
        }
        return storageOfTime;
    }

    /**
     * add missing two times when 2 dates and no time is detected
     * 
     * @param storageOfTime
     *            : contains time detected
     * @param storageOfDate
     *            : contains date detected
     * @throws ParseException
     */
    private void addTimeWhenNoTimeAndTwoDate(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {

        int numberBeforeCurrentDate = countNumberBeforeCurrentDate(storageOfDate);
        String currentTime = getCurrentTime();

        // today - today, today - tomorrow
        if (storageOfDate.get(0).equals(getCurrentDate())) {

            storageOfTime.add(currentTime);
            storageOfTime.add("23:59");

            // yesterday - today
        } else if (numberBeforeCurrentDate == 1) {

            storageOfTime.add("23:59");
            storageOfTime.add("23:59");

        } else {

            storageOfTime.add("00:00");
            storageOfTime.add("23:59");

        }
    }

    /**
     * add in the date that is not keyed in by the user and by the the right
     * interpreted
     * 
     * @param storageOfTime
     *            :time detected by user
     * @param storageOfDate
     *            date detected by user
     * @throws ParseException
     */
    private ArrayList<String> addInMissingDate(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate) throws ParseException {

        int numberBeforeCurrentTime = countNumberBeforeCurrentTime(storageOfTime);
        boolean isStartTimeBeforeCurrent = isStartTimeBeforeCurrent(storageOfTime);

        String currentDate = getCurrentDate();
        String nextDayDate = addDateToNumberOfDay(1, currentDate);
        String afterTwoDaysDate = addDateToNumberOfDay(2, currentDate);

        if (storageOfDate.size() < storageOfTime.size()) {

            if (storageOfDate.size() == 0 && storageOfTime.size() == 1) {

                addDateWhenZeroDateAndOneTime(storageOfDate,
                        numberBeforeCurrentTime, currentDate, nextDayDate);

            } else if (storageOfDate.size() == 0 && storageOfTime.size() == 2) {

                addDatesWhenZeroDateAndTwoTime(storageOfTime, storageOfDate,
                        numberBeforeCurrentTime, isStartTimeBeforeCurrent,
                        currentDate, nextDayDate, afterTwoDaysDate);

            } else if (storageOfDate.size() == 1 && storageOfTime.size() == 2) {

                addDateWhenOneDateAndTwoTimes(storageOfTime, storageOfDate,
                        numberBeforeCurrentTime, currentDate, nextDayDate);
            }

        }
        return storageOfDate;
    }

    /**
     * add dates when 0 date and 1 time was detected
     * 
     * @param storageOfDate
     *            : to be store with date
     * @param numberBeforeCurrentTime
     *            : number of time before current time
     * @param currentDate
     * @param nextDayDate
     *            : tomorrow date
     */
    private void addDateWhenZeroDateAndOneTime(ArrayList<String> storageOfDate,
            int numberBeforeCurrentTime, String currentDate, String nextDayDate) {

        if (numberBeforeCurrentTime == 1) {
            storageOfDate.add(nextDayDate);

        } else {

            storageOfDate.add(currentDate);

        }
    }

    /**
     * add when 1 dates and 2 times was detected
     * 
     * @param storageOfTime
     *            : contain the times detected
     * @param storageOfDate
     *            : to be store with date
     * @param numberBeforeCurrentTime
     *            : number of time before current time
     * @param currentDate
     * @param nextDayDate
     *            : tomorrow date
     * @throws ParseException
     *             : fail to parse date
     */
    private void addDateWhenOneDateAndTwoTimes(ArrayList<String> storageOfTime,
            ArrayList<String> storageOfDate, int numberBeforeCurrentTime,
            String currentDate, String nextDayDate) throws ParseException {

        if (storageOfTime.get(0).equals(storageOfTime.get(1))
                || isStartTimeLaterThanEnd(storageOfTime)) {

            storageOfDate.add(addDateToNumberOfDay(1, storageOfDate.get(0)));

        } else if (storageOfDate.get(0).equals(currentDate)
                && numberBeforeCurrentTime == 2) {

            storageOfDate.add(nextDayDate);

        } else if (!isStartTimeLaterThanEnd(storageOfTime)) {

            storageOfDate.add(storageOfDate.get(0));
        }
    }

    /**
     * add dates when 0 dates and 2 time is detected
     * 
     * @param storageOfTime
     *            :contains of time detcted
     * @param storageOfDate
     *            :to be stored with the new date
     * @param numberBeforeCurrentTime
     *            : number of times detected before current time
     * @param isStartTimeBeforeCurrent
     *            : true if start time is before current time
     * @param currentDate
     * @param nextDayDate
     * @param afterTwoDaysDate
     * @throws ParseException
     *             : fail to parse date
     */
    private void addDatesWhenZeroDateAndTwoTime(
            ArrayList<String> storageOfTime, ArrayList<String> storageOfDate,
            int numberBeforeCurrentTime, boolean isStartTimeBeforeCurrent,
            String currentDate, String nextDayDate, String afterTwoDaysDate)
            throws ParseException {

        if (storageOfTime.get(0).equals(storageOfTime.get(1))
                || (!isStartTimeBeforeCurrent && numberBeforeCurrentTime == 1)
                || (numberBeforeCurrentTime == 0 && isStartTimeLaterThanEnd(storageOfTime))) {

            storageOfDate.add(currentDate);
            storageOfDate.add(nextDayDate);

        } else if ((numberBeforeCurrentTime == 1 && isStartTimeBeforeCurrent)
                || (numberBeforeCurrentTime == 2 && !isStartTimeLaterThanEnd(storageOfTime))) {

            storageOfDate.add(nextDayDate);
            storageOfDate.add(nextDayDate);

        } else if (numberBeforeCurrentTime == 2
                && isStartTimeLaterThanEnd(storageOfTime)) {

            storageOfDate.add(nextDayDate);
            storageOfDate.add(afterTwoDaysDate);

        } else if (numberBeforeCurrentTime == 0
                && !isStartTimeLaterThanEnd(storageOfTime)) {

            storageOfDate.add(currentDate);
            storageOfDate.add(currentDate);
        }
    }

    /**
     * check if start time is later than end time
     * 
     * @param storageOfTime
     *            : contain time detected
     * @return true if start time later than end time otherwise false
     * @throws ParseException
     */
    private boolean isStartTimeLaterThanEnd(ArrayList<String> storageOfTime)
            throws ParseException {

        boolean isStartTimeLaterThanEnd = false;

        SimpleDateFormat timeFormat = new SimpleDateFormat(TIME_FORMAT);

        Date startTime = timeFormat.parse(storageOfTime.get(0));
        Calendar startTimeCalendar = Calendar.getInstance();
        startTimeCalendar.setTime(startTime);

        Date endTime = timeFormat.parse(storageOfTime.get(1));
        Calendar endTimecalendar = Calendar.getInstance();
        endTimecalendar.setTime(endTime);

        if (startTimeCalendar.getTime().after(endTimecalendar.getTime())) {
            isStartTimeLaterThanEnd = true;
        }

        return isStartTimeLaterThanEnd;
    }

    /**
     * get the current date in DD/MM/YYYY
     * 
     * @return date in DD/MM/YYYY
     */
    private static String getCurrentDate() {

        DateFormat date = new SimpleDateFormat(DATE_FORMAT);
        Calendar cal = Calendar.getInstance();
        String dateOfTheTask = date.format(cal.getTime());

        return dateOfTheTask;
    }

    /**
     * get date after adding the number of days
     * 
     * @param numberOfDay
     * @return DD/MM/YYYY
     * @throws ParseException
     *             : fail to parse
     */
    private static String addDateToNumberOfDay(int numberOfDay, String date)
            throws ParseException {

        DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);
        Date date1 = null;

        try {
            date1 = dateFormat.parse(date);

        } catch (ParseException e) {

            JOptionPane.showMessageDialog(null, e.getMessage());
            e.printStackTrace();
        }

        Calendar cal = Calendar.getInstance();
        cal.setTime(date1);

        cal.add(Calendar.DATE, numberOfDay);

        String dateOfTheTask = dateFormat.format(cal.getTime());

        return dateOfTheTask;
    }

    /**
     * get the current time in HH:MM
     * 
     * @return time in HH:MM
     */
    private static String getCurrentTime() {

        DateFormat dateFormat = new SimpleDateFormat(TIME_FORMAT);
        Calendar cal = Calendar.getInstance();
        String timeOfTheTask = dateFormat.format(cal.getTime());

        return timeOfTheTask;
    }

    /**
     * set the number of time stored in arrayList
     * 
     * @param storageOfParameters
     */
    public void setNumberOfTime(ArrayList<String> storageOfParameters) {
        numberOfTime = storageOfParameters.size();
    }

    /**
     * return the number of time detected and stored in arrayList
     * 
     * @return the number of time detected
     */
    public int getNumberOfTime() {
        return numberOfTime;
    }

    /**
     * 
     * @return userInput after the detection of all time and date
     */
    public String getUserInputLeft() {
        return description;
    }
}

	// End of segment: E:\main\src\parser\DateTimeParser.java





	/**
	 * origin: E:\main\src\parser\DateTimeParserTest.java
	 */

 *
 */
public class DateTimeParserTest {

    // test the addition of time when the user miss out
    @Test
    public void testWhenTimeNotKeyed() throws Exception {
        // deadline task without time added and have 1 date
        DateTimeParser d1 = new DateTimeParser(
                "add start reading ST2334 notes by this sat");
        assertEquals(d1.getEndTime(), "23:59");
        assertEquals(d1.getStartDate(), "-");
        assertEquals(d1.getEndDate(), "Sat 04/04/2015");
        assertEquals(d1.getStartTime(), "-");

        // deadline task without time and 1 date --> today
        DateTimeParser d4 = new DateTimeParser(
                "add start reading ST2334 notes by Friday");
        assertEquals(d4.getEndDate(), "Fri 03/04/2015");
        assertEquals(d4.getEndTime(), "23:59");
        assertEquals(d1.getStartDate(), "-");
        assertEquals(d1.getStartTime(), "-");

        // deadline task without time and 1 date
        DateTimeParser d6 = new DateTimeParser(
                "add start reading ST2334 notes next Friday");
        assertEquals(d6.getStartDate(), "-");
        assertEquals(d6.getStartTime(), "-");
        assertEquals(d6.getEndDate(), "Fri 10/04/2015");
        assertEquals(d6.getEndTime(), "23:59");

        // timed task with only one time added and 2 dates added
        DateTimeParser d2 = new DateTimeParser(
                "CS2103T assignments 23/2/2016 24/3/2016 4pm");
        assertEquals(d2.getStartDate(), "Tues 23/02/2016");
        assertEquals(d2.getEndDate(), "Thur 24/03/2016");
        assertEquals(d2.getStartTime(), "16:00");
        assertEquals(d2.getEndTime(), "23:59");

        // timed task with no time added and 2 dates
        DateTimeParser d3 = new DateTimeParser(
                "CS2103T assignments 23/2/2016 24/3/2016");
        assertEquals(d3.getStartDate(), "Tues 23/02/2016");
        assertEquals(d3.getEndDate(), "Thur 24/03/2016");
        assertEquals(d3.getStartTime(), "00:00");
        assertEquals(d3.getEndTime(), "23:59");

        // timed task with no time added and 2 dates(today, tomorrow)
        DateTimeParser d5 = new DateTimeParser(
                "CS2103T assignments today tomorrow");
        assertEquals(d5.getStartDate(), "Fri 03/04/2015");
        assertEquals(d5.getEndDate(), "Sat 04/04/2015");
        // current time is set for start time pls ensure that it is set to ur
        // com current time
        // assertEquals(d5.getStartTime(), "19:55");
        assertEquals(d5.getEndTime(), "23:59");

        // timed task with no time added and 2 dates(today, today)
        DateTimeParser d7 = new DateTimeParser(
                "CS2103T assignments today 03/04");
        assertEquals(d7.getStartDate(), "Fri 03/04/2015");
        assertEquals(d7.getEndDate(), "Fri 03/04/2015");
        // current time is set for start time pls ensure that it is set to ur
        // com current time
        // assertEquals(d7.getStartTime(), "19:53");
        assertEquals(d7.getEndTime(), "23:59");

        // timed task with 1 times and 2 dates (yesterday and today)
        DateTimeParser d8 = new DateTimeParser(
                "CS2103T assignments 02/04/2015 03/04 2pm");
        assertEquals(d8.getStartDate(), "Thur 02/04/2015");
        assertEquals(d8.getEndDate(), "Fri 03/04/2015");
        assertEquals(d8.getStartTime(), "14:00");
        assertEquals(d8.getEndTime(), "23:59");

        // timed task with 1 time added and 2 dates(today, today)
        DateTimeParser d9 = new DateTimeParser(
                "CS2103T assignments today 03/04 noon");
        assertEquals(d9.getStartDate(), "Fri 03/04/2015");
        assertEquals(d9.getEndDate(), "Fri 03/04/2015");
        assertEquals(d9.getStartTime(), "12:00");
        assertEquals(d9.getEndTime(), "23:59");

        // timed task with 1 time added and 2 dates(random date past current
        // date)
        DateTimeParser d10 = new DateTimeParser(
                "CS2103T assignments 05 sep and 24 dec midnight");
        assertEquals(d10.getStartDate(), "Sat 05/09/2015");
        assertEquals(d10.getEndDate(), "Thur 24/12/2015");
        assertEquals(d10.getStartTime(), "00:00");
        assertEquals(d10.getEndTime(), "23:59");
    }

    @Test
    // take note that if date is not added and there is time, I set the default
    // to current date
    // When testing, do change the expected result's date to current date.
    // and if the time pass the current time, it will the next day
    // PS: current date : 05/04 current time : 3pm
    public void testWhenDateNotKeyed() throws Exception {
        // deadline task without date added and past current time : 3pm
        DateTimeParser d1 = new DateTimeParser("CS2103T assignments due 10pm");
        assertEquals(d1.getEndDate(), "Sun 05/04/2015");
        assertEquals(d1.getEndTime(), "22:00");
        assertEquals(d1.getStartDate(), "-");
        assertEquals(d1.getStartTime(), "-");

        // deadline task without date added and before current time : 3pm
        DateTimeParser d6 = new DateTimeParser("CS2103T assignments due 8am");
        assertEquals(d6.getEndDate(), "Mon 06/04/2015");
        assertEquals(d6.getEndTime(), "08:00");
        assertEquals(d6.getStartDate(), "-");
        assertEquals(d6.getStartTime(), "-");

        // timed task with one date added start time is later than end time
        DateTimeParser d2 = new DateTimeParser(
                "CS2103T assignments 5pm to 4pm 23/06/2016");
        assertEquals(d2.getStartDate(), "Thur 23/06/2016");
        assertEquals(d2.getEndDate(), "Fri 24/06/2016");
        assertEquals(d2.getStartTime(), "17:00");
        assertEquals(d2.getEndTime(), "16:00");

        // timed task with one date added start time is later than end time
        DateTimeParser d10 = new DateTimeParser(
                "CS2103T assignments 1pm to 7pm 23/06/2016");
        assertEquals(d10.getStartDate(), "Thur 23/06/2016");
        assertEquals(d10.getEndDate(), "Thur 23/06/2016");
        assertEquals(d10.getStartTime(), "13:00");
        assertEquals(d10.getEndTime(), "19:00");

        // timed task with one date (today) added and 2 times past current
        // time:3pm
        DateTimeParser d11 = new DateTimeParser(
                "CS2103T assignments 9pm to 10pm today");
        assertEquals(d11.getStartDate(), "Sun 05/04/2015");
        assertEquals(d11.getEndDate(), "Sun 05/04/2015");
        assertEquals(d11.getStartTime(), "21:00");
        assertEquals(d11.getEndTime(), "22:00");

        // timed task with one date (today) added and 2 times past current
        // time:3pm with start>end time
        DateTimeParser d12 = new DateTimeParser(
                "CS2103T assignments 10pm to 9pm today");
        assertEquals(d12.getStartDate(), "Sun 05/04/2015");
        assertEquals(d12.getEndDate(), "Mon 06/04/2015");
        assertEquals(d12.getStartTime(), "22:00");
        assertEquals(d12.getEndTime(), "21:00");

        // timed task with no date added and start time is not later than end
        // time
        DateTimeParser d3 = new DateTimeParser("CS2103T assignments 4pm 6:30pm");
        assertEquals(d3.getStartDate(), "Sun 05/04/2015");
        assertEquals(d3.getEndDate(), "Sun 05/04/2015");
        assertEquals(d3.getStartTime(), "16:00");
        assertEquals(d3.getEndTime(), "18:30");

        // timed task with no date added and start time is later than end time
        DateTimeParser d4 = new DateTimeParser("CS2103T assignments 9pm 6:45pm");
        assertEquals(d4.getStartDate(), "Sun 05/04/2015");
        assertEquals(d4.getEndDate(), "Mon 06/04/2015");
        assertEquals(d4.getStartTime(), "21:00");
        assertEquals(d4.getEndTime(), "18:45");

        // timed task with no date added and end time before current time : 3pm
        DateTimeParser d5 = new DateTimeParser("CS2103T assignments 5pm 1pm");
        assertEquals(d5.getStartDate(), "Sun 05/04/2015");
        assertEquals(d5.getEndDate(), "Mon 06/04/2015");
        assertEquals(d5.getStartTime(), "17:00");
        assertEquals(d5.getEndTime(), "13:00");

        // timed task with no date added and past current time :3pm
        DateTimeParser d7 = new DateTimeParser(
                "CS2103T assignments 10pm 11:10pm");
        assertEquals(d7.getStartDate(), "Sun 05/04/2015");
        assertEquals(d7.getEndDate(), "Sun 05/04/2015");
        assertEquals(d7.getStartTime(), "22:00");
        assertEquals(d7.getEndTime(), "23:10");

    }

    @Test
    public void testWhenSameTime() throws Exception {
        // test when same time is detected with no date detected
        DateTimeParser d3 = new DateTimeParser(
                "CS2103T assignments 6:30pm 6:30pm");
        assertEquals(d3.getStartDate(), "Sun 05/04/2015");
        assertEquals(d3.getEndDate(), "Mon 06/04/2015");
        assertEquals(d3.getStartTime(), "18:30");
        assertEquals(d3.getEndTime(), "18:30");

        // test when same time is detected with 1 date detected
        DateTimeParser d4 = new DateTimeParser("25/4 6:30pm 6:30pm assignments");
        assertEquals(d4.getStartDate(), "Sat 25/04/2015");
        assertEquals(d4.getEndDate(), "Sun 26/04/2015");
        assertEquals(d4.getStartTime(), "18:30");
        assertEquals(d4.getEndTime(), "18:30");

    }

    @Test
    public void normalTest() throws Exception {
        // deadlines test
        DateTimeParser d1 = new DateTimeParser(
                "CS2103T assignments due 23/5/2015 2pm");
        assertEquals(d1.getEndDate(), "Sat 23/05/2015");
        assertEquals(d1.getEndTime(), "14:00");
        assertEquals(d1.getStartDate(), "-");
        assertEquals(d1.getStartTime(), "-");

        // timed test
        DateTimeParser d2 = new DateTimeParser(
                "CS2103T exam on 24/5 27/09/2015 from 2pm to 4:30pm.");
        assertEquals(d2.getStartTime(), "14:00");
        assertEquals(d2.getEndTime(), "16:30");
        assertEquals(d2.getEndDate(), "Sun 27/09/2015");
        assertEquals(d2.getStartDate(), "Sun 24/05/2015");

        // floating test
        DateTimeParser d3 = new DateTimeParser("happy!!!!!!!!!!");
        assertEquals(d3.getStartTime(), "-");
        assertEquals(d3.getEndTime(), "-");
        assertEquals(d3.getEndDate(), "-");
        assertEquals(d3.getStartDate(), "-");
    }

    @Test
    /**
     * test the remaindar pop-up message
     * Pls be remind that this test case is sensitive to the current time of your computer
     * set it according 
     */
    public void testForRemaindar() throws Exception {
        // today --> start time before current time but one end time past.
        DateTimeParser d4 = new DateTimeParser("add 03 April 4pm 8pm");
        assertEquals(d4.getStartDate(), "Fri 03/04/2015");
        assertEquals(d4.getEndDate(), "Fri 03/04/2015");
        assertEquals(d4.getStartTime(), "16:00");
        assertEquals(d4.getEndTime(), "20:00");

        // today --> start time and end time before current time
        DateTimeParser d5 = new DateTimeParser("add 03 April 6pm 5pm");
        assertEquals(d5.getStartDate(), "Fri 03/04/2015");
        assertEquals(d5.getEndDate(), "Sat 04/04/2015");
        assertEquals(d5.getStartTime(), "18:00");
        assertEquals(d5.getEndTime(), "17:00");

        // yesterday, today
        DateTimeParser d6 = new DateTimeParser("02/04 today dasdh");
        assertEquals(d6.getStartDate(), "Thur 02/04/2015");
        assertEquals(d6.getEndDate(), "Fri 03/04/2015");
        assertEquals(d6.getStartTime(), "23:59");
        assertEquals(d6.getEndTime(), "23:59");

    }

    @Test
    public void testForDash() throws Exception {
        DateTimeParser d1 = new DateTimeParser("dasdh");
        assertEquals(d1.getStartDate(), "-");
        assertEquals(d1.getEndDate(), "-");
        assertEquals(d1.getStartTime(), "-");
        assertEquals(d1.getEndTime(), "-");
    }

    /*
     * test for error like : 1) start time > end time 2) start date > end date
     */

    public void testError() throws Exception {
        // should pop up error window in gui
        // test for 2) start date > end date
        DateTimeParser d10 = new DateTimeParser(
                "CS2103T assignments 05 sep and 24 aug noon");

        // test for 1) start time > end time
        DateTimeParser d11 = new DateTimeParser("CS2103T assignments today 7pm");

    }

    // test position like past midnight will be detect 1st by time1Parser then
    // noon will then be
    // detect by dateTimeNatty (detect in this way: 00:01 --> 12) but the right
    // time position
    // should be 12:00 --> 00:01
    // check if the result be 12:00 --> 00:01
    @Test
    public void testPosition() throws Exception {

        DateTimeParser dt = new DateTimeParser("mds sale noon past midnight");

        assertEquals("12:00", dt.getStartTime());

        assertEquals("00:01", dt.getEndTime());

        // date: 13:00 and apr 24 will detected 1st.
        // check that the position of time and date is 12:00 --> 13:00
        // 24/04/2015 --> 25/04/2015
        // even though 13:00 and apr 24 will be detected and stored 1st
        DateTimeParser dt1 = new DateTimeParser(
                "la ala la 1200h to 13:00  Apr 24 to 25/4 ");

        assertEquals("12:00", dt1.getStartTime());

        assertEquals("13:00", dt1.getEndTime());
        assertEquals("Fri 24/04/2015", dt1.getStartDate());

        assertEquals("Sat 25/04/2015", dt1.getEndDate());

    }

    @Test
    /**
     * test those that could be detect in both dateParser and natty
     * ensure that the date extract is the right date
     */
    public void testForComplication() throws Exception {
        // the tues before

        DateTimeParser dateTime5 = new DateTimeParser(
                "two tuesday before 24/5 ");
        assertEquals("Tues 12/05/2015", dateTime5.getEndDate());
        assertEquals("-", dateTime5.getStartDate());
        assertEquals("-", dateTime5.getStartTime());
        assertEquals("23:59", dateTime5.getEndTime());

        // the tues after

        DateTimeParser dateTime6 = new DateTimeParser(
                "two tuesday after 24 May ");
        assertEquals("Tues 02/06/2015", dateTime6.getEndDate());
        assertEquals("-", dateTime6.getStartDate());
        assertEquals("-", dateTime6.getStartTime());
        assertEquals("23:59", dateTime6.getEndTime());

        // the tues after mix with those detected in dateParser

        DateTimeParser dateTime7 = new DateTimeParser(
                "two tuesday after 24/5  24/6");
        assertEquals("Tues 02/06/2015", dateTime7.getStartDate());
        assertEquals("Wed 24/06/2015", dateTime7.getEndDate());
        assertEquals("00:00", dateTime7.getStartTime());
        assertEquals("23:59", dateTime7.getEndTime());

        // next sat or sun

        DateTimeParser dateTime8 = new DateTimeParser("sat and sun");
        assertEquals("Sat 11/04/2015", dateTime8.getStartDate());
        assertEquals("Sun 12/04/2015", dateTime8.getEndDate());
        assertEquals("00:00", dateTime8.getStartTime());
        assertEquals("23:59", dateTime8.getEndTime());

    }
}

	// End of segment: E:\main\src\parser\DateTimeParserTest.java





	/**
	 * origin: E:\main\src\parser\DescriptionParser.java
	 */

 *
 */
public class DescriptionParser {
    private String description = "";

    public DescriptionParser(String userInput, String userInputLeft)
            throws Exception {

        // to match with partOfDescription since all is set to lowercase during
        // detection of time and date to prevent case sensitive
        String lowerCaseInput = switchAllToLowerCase(userInput);

        String partOfDescription = userInputLeft;

        String escapedText = getEscapedText(userInput);

        String[] eachWordInLeftOverInput = splitStringByWhitespace(partOfDescription);
        String[] eachEscapedText = splitStringByWhitespace(escapedText);
        String[] eachWordLowerCaseInput = splitStringByWhitespace(lowerCaseInput);
        String[] eachWordUserInput = splitStringByWhitespace(userInput);

        description = piecePartsOfDescription(eachWordInLeftOverInput, eachEscapedText,
                eachWordLowerCaseInput, eachWordUserInput);

        description = removeTheExtraSpace(description);
        setDescription(description);
    }

    /**
     * get the escape text which is surround with ~ eg: ~2dec~
     * 
     * @param userInput
     * @return escape text from ~~
     */
    private String getEscapedText(String userInput) {
        EscapedTextParser escapedTextParser = new EscapedTextParser(userInput);

        String escapedText = escapedTextParser.getEscapedText();

        escapedText = switchAllToLowerCase(escapedText);

        return escapedText;
    }

    private String removeTheExtraSpace(String partOfDescription) {
        partOfDescription = partOfDescription.trim();
        partOfDescription = partOfDescription.replaceAll("\\s+", " ");
        return partOfDescription;
    }

    /**
     * piece the left over user input (after extracting out time and date), the
     * escape text together and remove the conjunction that is in front of time
     * and date.
     * 
     * @param escapedText
     *            : those surround with ~ eg: ~12 dec~
     * @param partOfDescription
     *            : after extracting time, date and escaped text
     * @param lowerCaseInput
     *            : to match with part of description
     * @param userInput
     *            : to be piece together if it is not date and time in the way
     *            user typed
     * @return description
     */
    private String piecePartsOfDescription(String[] eachWordInLeftOverInput,
            String[] eachEscapedText, String[] eachWordLowerCaseInput, String[] eachWordUserInput) {

        int indexLeftOverInput = 0, indexEscapedText = 0;

        for (int i = 0; i < eachWordLowerCaseInput.length; i++) {
            boolean isByPassConjunction = isByPassConjunction(
                    indexLeftOverInput, indexEscapedText,
                    eachWordInLeftOverInput, eachEscapedText,
                    eachWordLowerCaseInput, i);

            if (isByPassConjunction) {
                indexLeftOverInput++;
                i++;
            }

            if (isWordEqualToUserInput(indexLeftOverInput,
                    eachWordInLeftOverInput, eachWordLowerCaseInput, i)) {

                indexLeftOverInput = addWordToDescription(indexLeftOverInput,
                        eachWordUserInput, i);
            } else if (isWordEqualToUserInput(indexEscapedText,
                    eachEscapedText, eachWordLowerCaseInput, i)) {

                indexEscapedText = addWordToDescription(indexEscapedText,
                        eachWordUserInput, i);
            }
        }
        return description;
    }

    /**
     * if escaped text or left over input match with the user input, add it to
     * the description
     * 
     * @param index
     * @param eachWordUserInput
     * @param i
     * @return the next index for continue detection of description
     */
    private int addWordToDescription(int index, String[] eachWordUserInput,
            int i) {
        description = description + " " + eachWordUserInput[i];
        index++;
        return index;
    }

    private boolean isWordEqualToUserInput(int index,
            String[] wordLeftOverInput, String[] eachWordLowerCaseInput, int i) {
        return index < wordLeftOverInput.length
                && eachWordLowerCaseInput[i].equals(wordLeftOverInput[index]);
    }

    /**
     * 1) change ~ to white space then split all by white space
     * 
     * @param text
     * @return array of each word in text
     */
    private String[] splitStringByWhitespace(String text) {
        text = text.replaceAll("\\~", " ");

        text = removeTheExtraSpace(text);

        String[] eachWordInDescription = text.split("\\s+|~");
        return eachWordInDescription;
    }

    /**
     * by pass the conjunction if it is link with date or time
     * 
     * @param indexLeftOverInput
     *            : index of eachWordInLeftOverInput
     * @param indexEscapedText
     *            : index of eachEscapedText
     * @param eachWordInLeftOverInput
     *            : left over input after extracting time and date
     * @param eachEscapedText
     *            : escaped text detected
     * @param eachWordLowerCaseInput
     *            : user input in lower case
     * @param i
     *            : index of eachWordLowerCaseInput
     * @return
     */
    private boolean isByPassConjunction(int indexLeftOverInput,
            int indexEscapedText, String[] eachWordInLeftOverInput,
            String[] eachEscapedText, String[] eachWordLowerCaseInput, int i) {

        boolean isByPassConjunction = false;
        if (indexLeftOverInput < eachWordInLeftOverInput.length
                && isConjunction(eachWordLowerCaseInput[i])
                && eachWordLowerCaseInput[i]
                        .equals(eachWordInLeftOverInput[indexLeftOverInput])) {

            if (isTheNextWordDate(indexLeftOverInput, indexEscapedText,
                    eachWordInLeftOverInput, eachEscapedText,
                    eachWordLowerCaseInput, i)
                    || isNextWordEmpty(indexLeftOverInput, indexEscapedText,
                            eachWordInLeftOverInput, eachEscapedText,
                            eachWordLowerCaseInput, i)) {
                isByPassConjunction = true;
            }

        }
        return isByPassConjunction;
    }

    /**
     * check if the next word of the left over input empty and it is empty not
     * because of escaped text but is because of the time and date extracted
     * out.
     * 
     * @param indexLeftOverInput
     *            : index of eachWordInLeftOverInput
     * @param indexEscapedText
     *            : index of eachEscapedText
     * @param eachWordInLeftOverInput
     *            : left over input after extracting time and date
     * @param eachEscapedText
     *            : escaped text detected
     * @param eachWordLowerCaseInput
     *            : user input in lower case
     * @param indexUserInput
     *            : index of eachWordLowerCaseInput
     * @return true if the next word is empty otherwise false.
     */
    private boolean isNextWordEmpty(int indexLeftOverInput,
            int indexEscapedText, String[] eachWordInLeftOverInput,
            String[] eachEscapedText, String[] eachWordLowerCaseInput,
            int indexUserInput) {

        return indexLeftOverInput == eachWordInLeftOverInput.length - 1
                && indexUserInput + 1 < eachWordLowerCaseInput.length
                && (indexEscapedText < eachEscapedText.length
                        && !eachWordLowerCaseInput[indexUserInput + 1]
                                .equals(eachEscapedText[indexEscapedText]) || indexEscapedText == eachEscapedText.length);
    }

    /**
     * check if the next word in the user input is time or date If yes, the next
     * word in left over input will not be equal to the next word in user input
     * and next word in user input will not be equal to escaped text.
     * 
     * @param indexLeftOverInput
     *            : index of eachWordInLeftOverInput
     * @param indexEscapedText
     *            : index of eachEscapedText
     * @param eachWordInLeftOverInput
     *            : left over input after extracting time and date
     * @param eachEscapedText
     *            : escaped text detected
     * @param eachWordLowerCaseInput
     *            : user input in lower case
     * @param indexUserInput
     *            : index of eachWordLowerCaseInput
     * @return true if next word contain time and date otherwise false
     */
    private boolean isTheNextWordDate(int indexLeftOverInput,
            int indexEscapedText, String[] eachWordInLeftOverInput,
            String[] eachEscapedText, String[] eachWordLowerCaseInput,
            int indexUserInput) {

        return indexLeftOverInput + 1 < eachWordInLeftOverInput.length

                && indexUserInput + 1 < eachWordLowerCaseInput.length

                && !eachWordInLeftOverInput[indexLeftOverInput + 1]
                        .equals(eachWordLowerCaseInput[indexUserInput + 1])

                && (indexEscapedText == eachEscapedText.length || (indexEscapedText < eachEscapedText.length && !eachWordLowerCaseInput[indexUserInput + 1]
                        .equals(eachEscapedText[indexEscapedText])));

    }

    /**
     * check if the text is conjunction
     * 
     * @param string
     *            : word
     * @return true if it is conjunction otherwise false
     */
    private boolean isConjunction(String text) {
        return text.matches("\\b(@|due on|on|at|from|to|by|due)\\b");
    }

    /**
     * to prevent case sensitive, switch all to lower case
     * 
     * @param userInput
     * @return the user input all in lower case.
     */
    private String switchAllToLowerCase(String userInput) {
        userInput = userInput.toLowerCase();
        return userInput;
    }

    /**
     * set description
     * 
     * @param detectedDescription
     */
    private void setDescription(String detectedDescription) {
        description = detectedDescription;

    }

    /**
     * Get the description.
     * 
     * @return the description
     */
    public String getDescription() {
        return description;
    }

}

	// End of segment: E:\main\src\parser\DescriptionParser.java





	/**
	 * origin: E:\main\src\parser\DescriptionParserTest.java
	 */

 *
 */
public class DescriptionParserTest {

    @Test
    public void withHashTagTest() throws Exception {

        MainParser m1 = new MainParser("~CS2103T assignment~ at 2pm 23/4");
        String userInputLeftOver = m1.getUserInputLeft();
        DescriptionParser d3 = new DescriptionParser(
                "~CS2103T assignment~ at 2pm 23/4", userInputLeftOver);
        assertEquals(d3.getDescription(), "CS2103T assignment");

        // To test for deadlines task and with escaped character
        // ~~ start of the statement
        MainParser m2 = new MainParser("~6am~ cafe at 2pm");
        userInputLeftOver = m2.getUserInputLeft();
        DescriptionParser d1 = new DescriptionParser("~6am~ cafe at 2pm",
                userInputLeftOver);
        assertEquals(d1.getDescription(), "6am cafe");

        // To test for timed task with escaped character
        // ~~middle of statement
        MainParser m3 = new MainParser("2pm to 7pm in ~6 in the morn~ 27/6");
        userInputLeftOver = m3.getUserInputLeft();
        DescriptionParser d2 = new DescriptionParser(
                "2pm to 7pm in ~6 in the morn~ 27/6", userInputLeftOver);
        assertEquals(d2.getDescription(), "in 6 in the morn");

        // ~~ end of the statement
        MainParser m4 = new MainParser("CS2103T assignment at ~2 jan~");
        String userInputLeftOver1 = m4.getUserInputLeft();
        DescriptionParser d5 = new DescriptionParser(
                "CS2103T assignment at ~2 jan~", userInputLeftOver1);
        assertEquals(d5.getDescription(), "CS2103T assignment at 2 jan");

        // ~~ more than 2
        MainParser m5 = new MainParser(
                "CS2103T ~tomorrow~ la la la on ~ooooo~ at 3pm 23/9 ");
        userInputLeftOver = m5.getUserInputLeft();
        DescriptionParser d7 = new DescriptionParser(
                "CS2103T ~tomorrow~ la la la on ~ooooo~ at 3pm 23/9 ",
                userInputLeftOver);
        assertEquals(d7.getDescription(), "CS2103T tomorrow la la la on ooooo");

        // no ~~
        MainParser m6 = new MainParser("CS2103T assignment on 2nd May at 2pm");
        userInputLeftOver = m6.getUserInputLeft();
        DescriptionParser d8 = new DescriptionParser(
                "CS2103T assignment on 2nd May at 2pm", userInputLeftOver);
        assertEquals(d8.getDescription(), "CS2103T assignment");

        // 1 ~ not 2
        MainParser m7 = new MainParser("CS2103T assignment on ~2nd december");
        userInputLeftOver = m7.getUserInputLeft();
        DescriptionParser d9 = new DescriptionParser(
                "CS2103T assignment on ~2nd december", userInputLeftOver);
        assertEquals(d9.getDescription(), "CS2103T assignment");

        // test ~with space hchhd~
        MainParser m8 = new MainParser(
                "CS2103T assignment on ~ 2nd december ~ at");
        userInputLeftOver = m8.getUserInputLeft();
        DescriptionParser d10 = new DescriptionParser(
                "CS2103T assignment on ~ 2nd december ~ at", userInputLeftOver);
        assertEquals(d10.getDescription(),
                "CS2103T assignment on 2nd december at");

        // test with having word join with ~ ~ as one word in the back
        MainParser m9 = new MainParser(
                "CS2103T assignment on ~2nd december~!!!!");
        userInputLeftOver = m9.getUserInputLeft();
        DescriptionParser d11 = new DescriptionParser(
                "CS2103T assignment on ~2nd december~!!!!", userInputLeftOver);
        assertEquals(d11.getDescription(),
                "CS2103T assignment on 2nd december !!!!");

        // test with having word join with ~ ~ as one word in the front
        MainParser m10 = new MainParser(
                "CS2103T assignment on !!!~2nd december~");
        userInputLeftOver = m10.getUserInputLeft();
        DescriptionParser d12 = new DescriptionParser(
                "CS2103T assignment on !!!~2nd december~", userInputLeftOver);
        assertEquals(d12.getDescription(),
                "CS2103T assignment on !!! 2nd december");

        // test with having word join with ~ ~ as one word in the front and back
        MainParser m11 = new MainParser(
                "e~2nd december~!!!  CS2103T assignment on");
        userInputLeftOver = m11.getUserInputLeft();
        DescriptionParser d13 = new DescriptionParser(
                "e~2nd december~!!! CS2103T assignment on", userInputLeftOver);
        assertEquals(d13.getDescription(),
                "e 2nd december !!! CS2103T assignment on");

        // test with having word join with ~ ~ as one word in the front and back
        MainParser m12 = new MainParser("!~task~!");
        userInputLeftOver = m12.getUserInputLeft();
        DescriptionParser d14 = new DescriptionParser("!~task~!",
                userInputLeftOver);
        assertEquals(d14.getDescription(), "! task !");

        // test with having word join with ~ ~ as one word in the front and back
        // with time
        MainParser m13 = new MainParser("dggdg~hhhh2pm~3pm24/03");
        userInputLeftOver = m13.getUserInputLeft();
        DescriptionParser d15 = new DescriptionParser(
                "dggdg~hhhh2pm~3pm on 24/3", userInputLeftOver);
        assertEquals(d15.getDescription(), "dggdg hhhh2pm");
        System.out.println("m13: " + m13.getEndDate());

    }

    @Test
    public void testWithoutHashTag() throws Exception {

        MainParser m2 = new MainParser("add complete developer guide on 13/04 ");
        String userInputLeftOver = m2.getUserInputLeft();
        DescriptionParser d11 = new DescriptionParser(
                "add complete developer guide on 13/04 ", userInputLeftOver);
        assertEquals(d11.getDescription(), "add complete developer guide");

        // test for timed task
        MainParser m1 = new MainParser("Superman from 2pm to 4pm");
        userInputLeftOver = m1.getUserInputLeft();
        DescriptionParser d10 = new DescriptionParser(
                "Superman from 2pm to 4pm", userInputLeftOver);
        assertEquals(d10.getDescription(), "Superman");

        // test for deadlines
        MainParser m3 = new MainParser(
                "CS2103T assignment at 20th April at 2pm");
        userInputLeftOver = m3.getUserInputLeft();
        DescriptionParser d8 = new DescriptionParser(
                "CS2103T assignment at 20th April at 2pm", userInputLeftOver);
        assertEquals(d8.getDescription(), "CS2103T assignment");

        MainParser m4 = new MainParser("On   sun for CS2103T assignment");
        userInputLeftOver = m4.getUserInputLeft();
        DescriptionParser d7 = new DescriptionParser(
                "On   sun for CS2103T assignment", userInputLeftOver);
        assertEquals(d7.getDescription(), "for CS2103T assignment");

        // test for floating
        MainParser m5 = new MainParser("CS2103T assignment!");
        userInputLeftOver = m5.getUserInputLeft();
        DescriptionParser d9 = new DescriptionParser("CS2103T assignment!",
                userInputLeftOver);
        assertEquals(d9.getDescription(), "CS2103T assignment!");

        // test for conjunction
        MainParser m6 = new MainParser(
                "gigi by assignment on next sun at 3pm at ivle from !");
        userInputLeftOver = m6.getUserInputLeft();
        DescriptionParser d14 = new DescriptionParser(
                "gigi by assignment on next sun at 3pm at ivle from !",
                userInputLeftOver);
        assertEquals(d14.getDescription(), "gigi by assignment at ivle from !");

    }

}

	// End of segment: E:\main\src\parser\DescriptionParserTest.java





	/**
	 * origin: E:\main\src\parser\EscapedTextParser.java
	 */

 *
 */
public class EscapedTextParser {
    private String textEscaped = "";
    private ArrayList<String> escapedTextList = new ArrayList<String>();

    public EscapedTextParser(String userInput) {
        escapedTextList = storeEscapedTexts(userInput);

        for (int i = 0; i < escapedTextList.size(); i++) {
            textEscaped = textEscaped + " " + escapedTextList.get(i);
        }

    }

    /**
     * get the escaped text ~....~ + ~.....~ + etc
     * 
     * @return the input left after removing all the time detected
     */
    public String getEscapedText() {
        return textEscaped;
    }

    /**
     * get the ArrayList of escaped text
     * 
     * @return ArrayList of escaped text
     */
    public ArrayList<String> getListOfEscapedText() {
        return escapedTextList;

    }

    /**
     * store all of the escaped text into a arrayList
     * 
     * @param userInput
     * @return arraylist of escaped text
     */
    private ArrayList<String> storeEscapedTexts(String userInput) {
        ArrayList<Integer> tildeIndex = new ArrayList<Integer>();
        ArrayList<String> tildeEscapedText = new ArrayList<String>();
        Pattern tildeDetector = Pattern.compile("\\~");
        Matcher containTilde = tildeDetector.matcher(userInput);

        while (containTilde.find()) {

            tildeIndex.add(containTilde.start());

            if (tildeIndex.size() == 2) {
                tildeEscapedText.add(userInput.substring(tildeIndex.get(0),
                        tildeIndex.get(1) + 1));
                tildeIndex.clear();
            }

        }
        return tildeEscapedText;
    }
}

	// End of segment: E:\main\src\parser\EscapedTextParser.java





	/**
	 * origin: E:\main\src\parser\EscapedTextParserTest.java
	 */

 *
 */
public class EscapedTextParserTest {

    @Test
    public void test() {
        // test with two ~ escaped char
        EscapedTextParser et1 = new EscapedTextParser("~6am~ cafe");
        assertEquals(et1.getEscapedText(), " ~6am~");

        // test 1 ~ escaped char
        EscapedTextParser et2 = new EscapedTextParser("~7pm jump");
        assertEquals(et2.getEscapedText(), "");

        // test no ~ escaped char
        EscapedTextParser et3 = new EscapedTextParser(" 7pm jump");
        assertEquals(et3.getEscapedText(), "");

        // test multiple ~~ escaped char
        EscapedTextParser et4 = new EscapedTextParser(
                "mds hdshsa ~oooo~ dhhd ~bye bye~ dhsah p~cgcgcg~l");
        assertEquals(et4.getEscapedText(), " ~oooo~ ~bye bye~ ~cgcgcg~");

        // test multiple ~~ escaped char with word at front and back
        EscapedTextParser et5 = new EscapedTextParser(
                "mds hdshsa~oooo~dhhd ~bye bye~ dhsah p~cgcgcg~l");
        assertEquals(et5.getEscapedText(), " ~oooo~ ~bye bye~ ~cgcgcg~");

        // test multiple ~~ escaped char with word at front
        EscapedTextParser et6 = new EscapedTextParser(
                "mds hdshsa~oooo~ dhhd ~bye bye~ dhsah p~cgcgcg~l");
        assertEquals(et6.getEscapedText(), " ~oooo~ ~bye bye~ ~cgcgcg~");

        // test multiple ~~ escaped char with word at back
        EscapedTextParser et7 = new EscapedTextParser(
                "mds hdshsa ~oooo~dhhd ~bye bye~dhsah p~cgcgcg~l");
        assertEquals(et7.getEscapedText(), " ~oooo~ ~bye bye~ ~cgcgcg~");
    }

}

	// End of segment: E:\main\src\parser\EscapedTextParserTest.java





	/**
	 * origin: E:\main\src\parser\IndexParser.java
	 */

 *
 */
public class IndexParser {
    private int index;
    private String input;

    public IndexParser(String userInput) {
        input = userInput;
    }

    /**
     * set the index
     * 
     * @param detectedIndex
     */
    private void setIndex(int detectedIndex) {
        index = detectedIndex;

    }

    /**
     * Extract the index.
     * 
     * @return positive index if number is detected, throw exception error if no
     *         digit is entered by the user. Since the program could not execute
     *         the command without the index (a digit) being detect.
     * @throws NumberFormatException
     *             when user enters a non-integer string
     */
    public int getIndex() throws NumberFormatException {
        int detectedIndex = 0;
        Logger logger = Logger.getLogger("IndexParser");

        try {
            logger.log(Level.INFO,
                    "going to start processing for detecting of index");
            String number = getNumber(input);
            detectedIndex = Integer.parseInt(number);

        } catch (NumberFormatException e) {
            logger.log(Level.WARNING, "No digit of input detected!");
            throw new NumberFormatException(input + " is not a number!\n");
        }

        setIndex(detectedIndex);

        return index;
    }

    /**
     * Use to get the index from a user input containing a lot of other text.
     * 
     * @param userInput
     * @return the index key by the user or the exception error when no digit is
     *         detect
     * @throws NumberFormatException
     *             ---> when no digit is detect, the user never key in the index
     *             and the command could not be execute without the index.
     */
    private String getNumber(String userInput) throws NumberFormatException {

        String number = "";
        Pattern indexDetector = Pattern.compile("\\d+");
        Matcher indexMatch = indexDetector.matcher(userInput);

        if (indexMatch.find()) {
            number = indexMatch.group();
        } else {
            throw new NumberFormatException("Index is not entered!!!");
        }

        return number;
    }
}

	// End of segment: E:\main\src\parser\IndexParser.java





	/**
	 * origin: E:\main\src\parser\IndexParserTest.java
	 */

 *
 */
public class IndexParserTest {

    @Test
    /**
     * test the boundary values when only 1 digit entered.
     */
    public void testWhenDigit() {
        IndexParser i2 = new IndexParser("delete 12");
        assertEquals(12, i2.getIndex());
    }

    @Test
    /**
     * test the boundary values when more than 1 digit is enter
     */
    public void testTwoOrMoreInput() {
        IndexParser i1 = new IndexParser("delete 1 2");
        assertEquals(1, i1.getIndex());
    }

}

	// End of segment: E:\main\src\parser\IndexParserTest.java





	/**
	 * origin: E:\main\src\parser\MainParser.java
	 */

 *
 */
public class MainParser {
    private String endDate;
    private String endTime;
    private String startTime;
    private String startDate;
    private String feedback;
    private String description;
    private String taskType;
    private String userInputLeft;
    public int numberOfTime;

    public MainParser(String userInput) throws Exception {

        DateTimeParser dateTimeParser = new DateTimeParser(userInput);
        endDate = dateTimeParser.getEndDate();
        startDate = dateTimeParser.getStartDate();
        startTime = dateTimeParser.getStartTime();
        endTime = dateTimeParser.getEndTime();
        feedback = dateTimeParser.getFeedBack();
        numberOfTime = dateTimeParser.getNumberOfTime();
        userInputLeft = dateTimeParser.getUserInputLeft();

        DescriptionParser descriptionParser = new DescriptionParser(userInput,
                userInputLeft);
        description = descriptionParser.getDescription();

        TaskTypeParser taskTypeParser = new TaskTypeParser(numberOfTime);
        taskType = taskTypeParser.getTaskType();
    }

    /**
     * get the number of time detected
     * 
     * @return number of time detected
     */
    public int getNumberOfTime() {
        return numberOfTime;
    }

    /**
     * get user input left after extracting all time and date detected
     * 
     * @return user input left
     */
    public String getUserInputLeft() {
        return userInputLeft;
    }

    public String getEndDate() {
        return endDate;
    }

    public String getStartDate() {
        return startDate;
    }

    public String getStartTime() {
        return startTime;
    }

    public String getEndTime() {
        return endTime;
    }

    public String getTaskType() {
        return taskType;
    }

    public String getDescription() {
        return description;
    }

    /**
     * get feedback like user keyed in tasks before current date and the start
     * time or date before current date
     * 
     * @return feedback message
     */
    public String getFeedback() {
        return feedback;
    }

}

	// End of segment: E:\main\src\parser\MainParser.java





	/**
	 * origin: E:\main\src\parser\MainParserTest.java
	 */

 *
 */
public class MainParserTest {

    @Test
    public void testDeadline() throws Exception {
        // deadline with no ~~
        MainParser m1 = new MainParser("CS2103T project submit at 13/4");
        assertEquals("CS2103T project submit", m1.getDescription());
        assertEquals("Mon 13/04/2015", m1.getEndDate());
        assertEquals("-", m1.getStartDate());
        assertEquals("-", m1.getStartTime());
        assertEquals("23:59", m1.getEndTime());
        assertEquals("deadline", m1.getTaskType());

        // deadine with ~~
        MainParser m2 = new MainParser(
                "Then go ~6am cafe~ to eat!!! at 14/4 2pm");
        assertEquals("Then go 6am cafe to eat!!!", m2.getDescription());
        assertEquals("Tues 14/04/2015", m2.getEndDate());
        assertEquals("-", m2.getStartDate());
        assertEquals("-", m2.getStartTime());
        assertEquals("14:00", m2.getEndTime());
        assertEquals("deadline", m2.getTaskType());
    }

    @Test
    public void testFloating() throws Exception {

        // floating with no ~~
        MainParser m1 = new MainParser("la la sing and sing!:)");
        assertEquals("la la sing and sing!:)", m1.getDescription());
        assertEquals("-", m1.getEndDate());
        assertEquals("-", m1.getStartDate());
        assertEquals("-", m1.getStartTime());
        assertEquals("-", m1.getEndTime());
        assertEquals("floating task", m1.getTaskType());

        // floating with ~~
        MainParser m2 = new MainParser("!~12/4~ dhdh ~2 jan 2014~ hdhdh ");
        assertEquals("! 12/4 dhdh 2 jan 2014 hdhdh", m2.getDescription());
        assertEquals("-", m2.getEndDate());
        assertEquals("-", m2.getStartDate());
        assertEquals("-", m2.getStartTime());
        assertEquals("-", m2.getEndTime());
        assertEquals("floating task", m2.getTaskType());
    }

    @Test
    // PS: it is current time sensitive. if 13:00 is before current time:
    // switch start and end to the next day
    public void testTime() throws Exception {

        // test timed
        MainParser m1 = new MainParser("go grandma house at 1300h to 6pm");
        assertEquals("go grandma house", m1.getDescription());
        assertEquals("Wed 08/04/2015", m1.getEndDate());
        assertEquals("Wed 08/04/2015", m1.getStartDate());
        assertEquals("13:00", m1.getStartTime());
        assertEquals("18:00", m1.getEndTime());
        assertEquals("time task", m1.getTaskType());

        // test timed with ~
        MainParser m2 = new MainParser(
                "~1300 to 6pm~ go go go ~hshdh ~ sisisi from 07/04 13:00 to 18:00");
        assertEquals("1300 to 6pm go go go hshdh sisisi", m2.getDescription());
        assertEquals("Tues 07/04/2015", m2.getEndDate());
        assertEquals("Tues 07/04/2015", m2.getStartDate());
        assertEquals("13:00", m2.getStartTime());
        assertEquals("18:00", m2.getEndTime());
        assertEquals("time task", m2.getTaskType());

    }
}

	// End of segment: E:\main\src\parser\MainParserTest.java





	/**
	 * origin: E:\main\src\parser\MonthParser.java
	 */

 *
 */
public class MonthParser {

    public MonthParser() {

    }

    /**
     * change month in word to month in int
     * 
     * @param dateOfTheTask
     * @return month in int
     */
    public static int convertMonthToNumber(String dateOfTheTask) {
        int month = 0;

        if (dateOfTheTask.contains("jan")) {
            month = 1;
        } else if (dateOfTheTask.contains("feb")) {
            month = 2;
        } else if (dateOfTheTask.contains("mar")) {
            month = 3;
        } else if (dateOfTheTask.contains("apr")) {
            month = 4;
        } else if (dateOfTheTask.contains("may")) {
            month = 5;
        } else if (dateOfTheTask.contains("jun")) {
            month = 6;
        } else if (dateOfTheTask.contains("jul")) {
            month = 7;
        } else if (dateOfTheTask.contains("aug")) {
            month = 8;
        } else if (dateOfTheTask.contains("sep")) {
            month = 9;
        } else if (dateOfTheTask.contains("oct")) {
            month = 10;
        } else if (dateOfTheTask.contains("nov")) {
            month = 11;
        } else if (dateOfTheTask.contains("dec")) {
            month = 12;
        }

        return month;
    }

    /**
     * get the month of the date in the format of dd/mm/yyyy
     * 
     * @param dateOfTheTask
     * @return month
     */
    public static int getMonth(String dateOfTheTask) {
        String[] ddmmyyyy = splitTheStringIntoPart(dateOfTheTask);

        assert ddmmyyyy.length != 3 || ddmmyyyy[1] != null;

        int month = Integer.parseInt(ddmmyyyy[1]);

        return month;
    }

    /**
     * split the date DD/MM/YYYY to day, month and year in the array of String
     * 
     * @param dateOfTheTask
     * @return day, month and year in string array.
     */
    public static String[] splitTheStringIntoPart(String dateOfTheTask) {
        String[] ddmmyyyy = null;

        if (dateOfTheTask.contains("/")) {
            ddmmyyyy = dateOfTheTask.split("(/)");
        } else if (dateOfTheTask.contains(".")) {
            ddmmyyyy = dateOfTheTask.split("(\\.)");
        } else if (dateOfTheTask.contains("-")) {
            ddmmyyyy = dateOfTheTask.split("(\\-)");
        }

        return ddmmyyyy;
    }
}

	// End of segment: E:\main\src\parser\MonthParser.java





	/**
	 * origin: E:\main\src\parser\MonthParserTest.java
	 */

 *
 */
public class MonthParserTest {

    @Test
    public void testConvertWordToInteger() {
        // jan and all squeeze together
        assertEquals(1, MonthParser.convertMonthToNumber("24jan2016"));

        // january and all squeeze together
        assertEquals(1, MonthParser.convertMonthToNumber("24january2016"));

        // feb
        assertEquals(2, MonthParser.convertMonthToNumber("24 feb2016"));

        // feburary
        assertEquals(2, MonthParser.convertMonthToNumber("24 february2016"));

        // march
        assertEquals(3, MonthParser.convertMonthToNumber("24 march 2016"));

        // mar
        assertEquals(3, MonthParser.convertMonthToNumber("24 mar"));

        // April
        assertEquals(4, MonthParser.convertMonthToNumber("24 april 2016"));

        // apr
        assertEquals(4, MonthParser.convertMonthToNumber("24 apr"));

        // may
        assertEquals(5, MonthParser.convertMonthToNumber("24 may 2016"));

        // june
        assertEquals(6, MonthParser.convertMonthToNumber("24 june 2016"));

        // jun
        assertEquals(6, MonthParser.convertMonthToNumber("24 jun"));

        // july
        assertEquals(7, MonthParser.convertMonthToNumber("24 july 2016"));

        // jul
        assertEquals(7, MonthParser.convertMonthToNumber("24 jul"));

        // august
        assertEquals(8, MonthParser.convertMonthToNumber("24 august 2016"));

        // aug
        assertEquals(8, MonthParser.convertMonthToNumber("24 aug"));

        // september
        assertEquals(9, MonthParser.convertMonthToNumber("24 september 2016"));

        // sep
        assertEquals(9, MonthParser.convertMonthToNumber("24 sep"));

        // octobor
        assertEquals(10, MonthParser.convertMonthToNumber("24 octobor 2016"));

        // oct
        assertEquals(10, MonthParser.convertMonthToNumber("24 oct"));

        // november
        assertEquals(11, MonthParser.convertMonthToNumber("24 november 2016"));

        // nov
        assertEquals(11, MonthParser.convertMonthToNumber("24 nov"));

        // december
        assertEquals(12, MonthParser.convertMonthToNumber("24 december 2016"));

        // dec
        assertEquals(12, MonthParser.convertMonthToNumber("24 dec"));

        // not detected
        assertEquals(0, MonthParser.convertMonthToNumber("dgsgsg"));
    }

}

	// End of segment: E:\main\src\parser\MonthParserTest.java





	/**
	 * origin: E:\main\src\parser\NumberParser.java
	 */

 *
 */
public class NumberParser {
    private static String[] wordOfNumDays = { "one", "two", "three", "four",
            "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve",
            "thirteen", "fourteen", "fifteen", "sixteen", "seventeen",
            "eighteen", "nineteen" };
    private static final String NUMBERIC_KEYWORD = "(\\b\\d+\\b)";
    private static final String DAY_KEYWORD = "(\\d+|\\w+)";
    private static final String MONTH_IN_WORD_KEYWORD = "(january|febuary|march|april|may|june|july|august|september|octobor|november|december)"
            + "|(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)";

    public NumberParser() {

    }

    /**
     * get the 1st number in word or digit before week, month, year
     * 
     * @param dateOfTheTask
     * @return number
     */
    public static int getNumber(String dateOfTheTask) {

        int number = 0;
        dateOfTheTask = dateOfTheTask.replaceAll(MONTH_IN_WORD_KEYWORD, "");
        Pattern numberPattern = Pattern.compile(DAY_KEYWORD);
        Matcher containNumber = numberPattern.matcher(dateOfTheTask);

        String text;

        if (containNumber.find()) {
            text = containNumber.group();

            if (isNumeric(text)) {
                number = Integer.parseInt(text);
            } else if (text.equals("twenty")) {
                text = dateOfTheTask.replaceAll(text, "");
                number = 20 + getNextWord(text);
            } else if (text.equals("thirty")) {
                text = dateOfTheTask.replaceAll(text, "");
                number = 30 + getNextWord(text);
            } else {
                number = determineIntFromWords(text);
            }
        }
        return number;
    }

    private static boolean isNumeric(String text) {
        return text.matches(NUMBERIC_KEYWORD);
    }

    /**
     * when the number of day is in word format change from word format to
     * integer format
     * 
     * @param numberInWord
     * @return number of day in integer.
     */
    private static int determineIntFromWords(String numberInWord) {

        int number = 1;

        for (int i = 0; i < wordOfNumDays.length; i++) {
            if (numberInWord.equals(wordOfNumDays[i])) {
                break;
            }
            number++;
        }

        // 20 means nothing from array(wordOfNumDays) is equal, no number of day
        // detect
        if (number == 20) {
            number = 0;
        }
        return number;
    }

    /**
     * get next word for case like twenty-two two would be return
     * 
     * @param text
     * @return next word
     */
    private static int getNextWord(String text) {
        int day = 0;
        Pattern numberPattern = Pattern.compile("\\w+");
        Matcher containNumber = numberPattern.matcher(text);

        if (containNumber.find()) {
            text = containNumber.group();
            day = determineIntFromWords(text);
        }
        return day;
    }

}

	// End of segment: E:\main\src\parser\NumberParser.java





	/**
	 * origin: E:\main\src\parser\NumberParserTest.java
	 */

 *
 */
public class NumberParserTest {

    @Test
    public void test() {
        // test dd/mm/yyyy
        assertEquals(24, NumberParser.getNumber("24/05/2015"));

        // test dd/mm
        assertEquals(25, NumberParser.getNumber("25/07"));

        // test dd/mm/yyyy when dd is word
        assertEquals(23, NumberParser.getNumber("twenty-three aug 2015"));

        // test dd/mm when dd is word
        assertEquals(31, NumberParser.getNumber("thirty-onejan"));

        // test dd/mm
        assertEquals(1, NumberParser.getNumber("1 feb"));

        // test dd/mm
        assertEquals(20, NumberParser.getNumber("20april"));

        // test mm/dd
        assertEquals(12, NumberParser.getNumber("mar12"));

        // test mm/dd
        assertEquals(4, NumberParser.getNumber("may4 2015"));

        // test mm/dd
        assertEquals(24, NumberParser.getNumber("november twenty-four 2015"));

        // test number of days
        assertEquals(24, NumberParser.getNumber("twenty-four day later"));
    }

}

	// End of segment: E:\main\src\parser\NumberParserTest.java





	/**
	 * origin: E:\main\src\parser\TaskTypeParser.java
	 */

 *
 */
public class TaskTypeParser {
    private String taskType;

    public TaskTypeParser(int numberOfTimeInput) throws Exception {
        String taskType = null;

        if (numberOfTimeInput == 2) {
            taskType = "time task";
        } else if (numberOfTimeInput == 1) {
            taskType = "deadline";
        } else if (numberOfTimeInput == 0) {
            taskType = "floating task";
        }

        assert taskType != null : "error in detection detect too many time! or user key more than 2 times";

        setTaskType(taskType);
    }

    /**
     * set the task type into this class
     * 
     * @param detectedTaskType
     */
    public void setTaskType(String detectedTaskType) {
        taskType = detectedTaskType;
    }

    /**
     * Determine the type of task.
     * 
     * @return the task type.
     */
    public String getTaskType() {
        return taskType;
    }
}

	// End of segment: E:\main\src\parser\TaskTypeParser.java





	/**
	 * origin: E:\main\src\parser\TaskTypeParserTest.java
	 */

 *
 */
public class TaskTypeParserTest {

    @Test
    /**
     * test time task, floating task, deadlines task
     */
    public void test() throws Exception {

        // floating task
        TaskTypeParser t2 = new TaskTypeParser(0);
        assertEquals("floating task", t2.getTaskType());

        // deadlines task
        TaskTypeParser t3 = new TaskTypeParser(1);
        assertEquals("deadline", t3.getTaskType());

        // time task
        TaskTypeParser t1 = new TaskTypeParser(2);
        assertEquals("time task", t1.getTaskType());

    }
}

	// End of segment: E:\main\src\parser\TaskTypeParserTest.java





	/**
	 * origin: E:\main\src\parser\TimeParser.java
	 */

 */
public class TimeParser {

    private final String TIME_TO_TIME_KEYWORD = "\\b(((\\d+[.:,](\\d+)|\\d+)(\\s|)(am|pm|a.m.|p.m.|a|p|)(\\s|)(to|-)(\\s|)(\\d+[.:,](\\d+)|\\d+)(\\s|)(am|pm|a.m.|p.m.|a|p|)))\\b";
    private final String HOURS_APART_KEYWORD = "\\b(\\d+[.:,]\\d+|\\d+)((\\s|)(am|pm||a.m.|p.m.|a|p|)) for \\d+(\\s|)(hour|hours|hr|hrs)\\b";
    private final String TIME_WITH_OCLOCK_KEYWORD = "\\b(\\d+[:.,]\\d+|\\d+)(\\s|)o('|)clock\\b";
    private final String TWELVE_HOUR_KEYWORD = "(\\d+[.,:]\\d+|\\d+)((\\s|)(am|pm|a.m.|p.m.|a|p))\\b";
    private final String BEFORE_NOON_BEFORE_MIDNIGHT_KEYWORD = "(\\b(before midnight|before noon)\\b)";
    private final String MORNING_AFTERNOON_NIGHT_KEYWORD = "(\\b(\\d+[.:,](\\d+)|\\d+)(\\s|)( (in (the |)|)(morning|morn)\\b| (in (the |)|)afternoon\\b| (in (the |)|)night\\b| at (the |)night\\b| at (the |)afternoon\\b"
            + "| at (the |)morning\\b| at (the |)morn\\b))";
    private final String TWENTY_FOUR_HH_KEYWORD = "(\\b\\d{1,2}[:.,]\\d{2}\\b) | (\\b\\d{4}\\b)";
    private final String PAST_NOON_PAST_MIDNIGHT_KEYWORD = "(\\b(past midnight|past noon|after noon|after midnight)\\b)";
    private final String TO_BE_REMOVED_KEYWORD = "(before midnight|before noon|"
            + "in afternoon|in night|in (morning|morn)|at afternoon|at night|at (morning|morn)|in the afternoon|in the night|in the (morning|morn)|at the afternoon|at the night|at the (morning|morn)|o'clock|past noon|past"
            + "midnight|after noon|after midnight|noon|midnight|\\s|afternoon|night|morning|morn|-|to|at|from|hours|hour|hrs|hr|(@ |due on |on |at |from |to |by |due |oclock))";
    private int index;
    private String userInputLeft;
    private ArrayList<String> storageOfTime = new ArrayList<String>();

    public TimeParser(String userInput) throws Exception {
        extractTime(userInput, userInput);
    }

    public void extractTime(String userInput, String leftOverUserInput)
            throws Exception {

        userInput = removeThoseHashTag(userInput);
        userInput = switchAllToLowerCase(userInput);

        leftOverUserInput = removeThoseHashTag(leftOverUserInput);
        leftOverUserInput = switchAllToLowerCase(leftOverUserInput);

        userInputLeft = leftOverUserInput;

        goThroughTimeFormat(userInput);
    }

    public int getPosition() {
        return index;
    }

    /**
     * get the input left
     * 
     * @return the input left after removing all the time detected
     */
    public String getInputLeft() {

        return userInputLeft;
    }

    /**
     * get the time list detected
     * 
     * @return storage of time : list of times detected
     */
    public ArrayList<String> getTimeList() {
        return storageOfTime;
    }

    /**
     * indication of ~~ means that user want it to be in description ~~ means
     * escaped char
     * 
     * @param userInput
     * @return user input without ~
     */
    private String removeThoseHashTag(String userInput) {

        EscapedTextParser escapedTextParser = new EscapedTextParser(userInput);
        ArrayList<String> escapedTextList = escapedTextParser
                .getListOfEscapedText();

        for (int i = 0; i < escapedTextList.size(); i++) {

            userInput = userInput.replaceAll(escapedTextList.get(i), " ");

        }

        return userInput;
    }

    /**
     * go through the list of time format
     * 
     * @param userInput
     * @throws Exception
     *             : fail to parse time and IllegalArgumentException : key in
     *             invalid 12 and 24 hour format
     */
    private void goThroughTimeFormat(String userInput) throws Exception {

        spotHourApartKeyword();
        spotBeforeMidnightOrNoonKeyword(userInput);
        spotMorningAfternoonNightKeyword(userInput);
        spotPastMidnightOrNoonKeyword(userInput);
        spotHHOclockKeyword(userInput);
        spotTimeToTimeKeyword();
        spotTwelveHourFormat(userInput);
        spotTwentyFourHHKeyword(userInput);

    }

    /**
     * detect HH:MM/HH with pm and am behind.
     * 
     * @param storageOfTime
     * @throws IllegalArgumentException
     *             : invalid 12 hour format > 12
     * @return storage of time containing the time detected.
     */
    private void spotTwelveHourFormat(String userInput)
            throws IllegalArgumentException {

        Pattern timeDetector = Pattern.compile(TWELVE_HOUR_KEYWORD);
        Matcher matchedWithTime = timeDetector.matcher(userInputLeft);
        Matcher matchedForIndex = timeDetector.matcher(userInput);

        while (matchedWithTime.find()) {
            String time = matchedWithTime.group();

            testValidTime(time);

            userInputLeft = userInputLeft.replaceAll(time, "");

            if (matchedForIndex.find()) {
                int indexNext = matchedForIndex.start();

                time = removeUnwantedParts(time);
                time = changeToHourFormat(time);

                assert checkValid24HourTime(time) == true : "Wrong convertion of time";

                storageOfTime.add(time);
                setThePositionForTime(indexNext);

            }
        }
    }

    /**
     * spot time with past midnight, past noon,
     * 
     * @param userInput
     */
    private void spotPastMidnightOrNoonKeyword(String userInput) {
        Pattern timeDetector = Pattern.compile(PAST_NOON_PAST_MIDNIGHT_KEYWORD);
        Matcher matchedWithTime = timeDetector.matcher(userInputLeft);
        Matcher matchedForIndex = timeDetector.matcher(userInput);

        while (matchedWithTime.find()) {

            userInputLeft = userInputLeft.replaceAll(
                    PAST_NOON_PAST_MIDNIGHT_KEYWORD, "");
            String time = matchedWithTime.group();

            if (matchedForIndex.find()) {
                int indexNext = matchedForIndex.start();

                if (time.contains("noon")) {
                    storageOfTime.add("12:01");
                } else if (time.contains("midnight")) {
                    storageOfTime.add("00:01");
                }

                index = indexNext;
                setThePositionForTime(indexNext);
            }
        }
    }

    /**
     * get 24 hour format time HH.MM/HH,MM
     * 
     * @param userInput
     * @throws IllegalArgumentException
     *             : invalid 24 hour > 23
     */
    private void spotTwentyFourHHKeyword(String userInput)
            throws IllegalArgumentException {
        Pattern timeDetector = Pattern.compile(TWENTY_FOUR_HH_KEYWORD);
        Matcher containTime = timeDetector.matcher(userInputLeft);
        Matcher toGetIndex = timeDetector.matcher(userInput);

        while (containTime.find()) {
            String time = containTime.group();
            testValidTime(time);
            userInputLeft = userInputLeft.replaceAll(time, "");

            if (toGetIndex.find()) {

                int indexNext = toGetIndex.start();
                time = removeUnwantedParts(time);
                time = changeToHourFormat(time);

                assert checkValid24HourTime(time) == true : "Wrong convention of time";

                storageOfTime.add(time);
                setThePositionForTime(indexNext);
            }
        }
    }

    /**
     * detect time + o'clock and have a default morning
     * 
     * @param userInput
     */
    private void spotHHOclockKeyword(String userInput) {
        Pattern timeDetector = Pattern.compile(TIME_WITH_OCLOCK_KEYWORD);
        Matcher containTime = timeDetector.matcher(userInputLeft);
        Matcher toGetIndex = timeDetector.matcher(userInput);

        while (containTime.find()) {
            String time = containTime.group();

            testValidTime(time);
            userInputLeft = userInputLeft.replaceAll(time, "");

            if (toGetIndex.find()) {

                int indexNext = toGetIndex.start();
                time = removeUnwantedParts(time);
                time = changeToHourFormat(time);

                assert checkValid24HourTime(time) == true : "Wrong convention of time";

                storageOfTime.add(time);
                setThePositionForTime(indexNext);
            }
        }
    }

    /**
     * to prevent case sensitive, switch all to lower case
     * 
     * @param userInput
     * @return the user input all in lower case.
     */
    private String switchAllToLowerCase(String userInput) {
        userInput = userInput.replaceAll("\\s+", " ");
        userInput = " " + userInput.toLowerCase() + " ";
        return userInput;
    }

    /**
     * detect the start at __ am/pm for __ hour
     * 
     */
    private void spotHourApartKeyword() throws IllegalArgumentException {

        Pattern containTime = Pattern.compile(HOURS_APART_KEYWORD);
        Matcher toGetIndex = containTime.matcher(userInputLeft);

        while (toGetIndex.find()) {
            String time = toGetIndex.group();
            userInputLeft = userInputLeft.replaceAll(time, "");

            String startTime = detectStartTime(time);
            testValidTime(startTime);
            startTime = changeToHourFormat(startTime);
            int hhInTime = getHH(startTime);

            String numberOfHour = detectNumberOfHour(time);
            int numberOfHours = Integer.parseInt(numberOfHour);

            hhInTime = addTimeWithHours(numberOfHours, hhInTime);
            String hhTimeInString = toString(hhInTime);
            String minTime = getMinutes(startTime);

            time = hhTimeInString + ":" + minTime;

            assert checkValid24HourTime(time) == true : "Wrong convention of time";

            storageOfTime.add(startTime);
            storageOfTime.add(time);
        }

    }

    /**
     * convert the integer of HH to string
     * 
     * @param hhInTime
     * @return HH in string
     */
    private String toString(int hhInTime) {
        String hhTimeInString;

        if (hhInTime < 10) {
            hhTimeInString = "0" + hhInTime;
        } else {
            hhTimeInString = "" + hhInTime;
        }

        return hhTimeInString;
    }

    /**
     * add time with the number of hour
     * 
     * @param numberOfHours
     * @param hhInTime
     * @return HH in time
     */
    private int addTimeWithHours(int numberOfHours, int hhInTime) {

        hhInTime = hhInTime + numberOfHours;

        if (hhInTime > 23) {
            hhInTime = hhInTime - 24;
        }
        return hhInTime;
    }

    /**
     * detect time with or without pm/am
     * 
     * @param time
     * @return time with or without am/pm
     */
    private String detectStartTime(String time) {
        String digit1 = "(\\d+[.:,](\\d+)|\\d+)((\\s|)(am|pm|a.m.|p.m.|a|p|))";

        Pattern containTime = Pattern.compile(digit1);
        Matcher matchedWithTime = containTime.matcher(time);

        if (matchedWithTime.find()) {
            time = matchedWithTime.group();
        }
        return time;
    }

    /**
     * detect digit represent the number of hours
     * 
     * @param time
     * @return number of hour
     */
    private String detectNumberOfHour(String time) {
        String digit = "(\\d+)";
        String numberOfHour = "";
        Pattern timeDetector1 = Pattern.compile(digit);
        Matcher matchedWithTime1 = timeDetector1.matcher(time);

        while (matchedWithTime1.find()) {
            numberOfHour = matchedWithTime1.group();
        }

        return numberOfHour;
    }

    /**
     * detect the time like 6 in morning or 6 in afternoon or 6 in night
     * 
     */
    private void spotMorningAfternoonNightKeyword(String userInput) {
        Pattern timeDetector = Pattern.compile(MORNING_AFTERNOON_NIGHT_KEYWORD);
        Matcher matchedWithTime = timeDetector.matcher(userInputLeft);
        Matcher matchedForIndex = timeDetector.matcher(userInput);

        while (matchedWithTime.find()) {
            String time = matchedWithTime.group();
            userInputLeft = userInputLeft.replaceAll(time, "");

            if (matchedForIndex.find()) {
                int indexNext = matchedForIndex.start();

                if (time.contains("morning") || time.contains("morn")) {

                    time = removeUnwantedParts(time);
                    testValidTime(time);
                    time = changeToHourFormat(time + "am");

                } else if (time.contains("afternoon") || time.contains("night")) {
                    time = removeUnwantedParts(time);
                    testValidTime(time);
                    time = changeToHourFormat(time + "pm");
                }

                storageOfTime.add(time);
                assert checkValid24HourTime(time) == true : "Wrong convertion of time";
                setThePositionForTime(indexNext);
            }
        }
    }

    /**
     * detect start time and end time. able to detect HH:MM or 12hour format
     * with pm or am or none to or - HH:MM or 12hour format pm or am example: 1)
     * 12:30 - 1pm 2) 12pm to 1:30pm
     * 
     * @throws ParseException
     * 
     */
    private void spotTimeToTimeKeyword() throws Exception {

        Pattern timeDetector = Pattern.compile(TIME_TO_TIME_KEYWORD);
        Matcher matchedWithTime = timeDetector.matcher(userInputLeft);

        while (matchedWithTime.find()) {
            String time = matchedWithTime.group();
            String[] timeList = time.split("-|to");

            boolean isBothContainsAmPm = ifBothContainsAmPm(timeList);
            boolean isStartTimeContainsAmPm = ifStartTimeContainsAmPm(timeList);

            if (isAtleastOneAMPM(timeList)) {
                if (isBothContainsAmPm) {
                    addTimeWhenBothHaveMeridim(timeList);
                } else if (isStartTimeContainsAmPm) {
                    addTimeWhenStartTimeMeridiem(timeList);
                } else {
                    addTimeWhenEndTimeMeridiem(timeList);
                }

                if (storageOfTime.size() == 2) {
                    userInputLeft = userInputLeft.replaceAll(time, "");
                }
            }
        }
    }

    private boolean isAtleastOneAMPM(String[] timeList) {

        boolean isAtleastOneAMPM = false;

        if ((timeList[0].contains("a") || timeList[0].contains("p"))
                || (timeList[1].contains("a") || timeList[1].contains("p"))) {
            isAtleastOneAMPM = true;
        }
        return isAtleastOneAMPM;
    }

    /**
     * add the time when both have am/pm
     * 
     * @param timeList
     */
    private void addTimeWhenBothHaveMeridim(String[] timeList) {
        testValidTime(timeList[0]);
        testValidTime(timeList[1]);
        timeList[0] = removeUnwantedParts(timeList[0]);
        timeList[1] = removeUnwantedParts(timeList[1]);
        timeList[0] = changeToHourFormat(timeList[0]);
        timeList[1] = changeToHourFormat(timeList[1]);

        assert checkValid24HourTime(timeList[0]) == true : "Wrong convertion of time";
        assert checkValid24HourTime(timeList[1]) == true : "Wromg convertion of time";

        storageOfTime.add(timeList[0]);
        storageOfTime.add(timeList[1]);
    }

    /**
     * check that both time contain am/pm
     * 
     * @param timeList
     * @return
     */
    private boolean ifBothContainsAmPm(String[] timeList) {
        boolean isBothContainsAmPm = false;
        if ((timeList[0].contains("a") || timeList[0].contains("p"))
                && (timeList[1].contains("a") || timeList[1].contains("p"))) {
            isBothContainsAmPm = true;
        }
        return isBothContainsAmPm;
    }

    /**
     * add start time when the end time contains am/pm
     * 
     * @param timeList
     * @throws ParseException
     */
    private void addTimeWhenEndTimeMeridiem(String[] timeList)
            throws ParseException {

        String timeWithMeridiem = timeList[1];
        String timeWithoutMeridiem = timeList[0];
        timeWithoutMeridiem = timeWithoutMeridiem.trim();
        testValidTime(timeWithMeridiem);
        timeWithMeridiem = changeToHourFormat(timeWithMeridiem);

        if (isNotHHMMFormat(timeWithoutMeridiem)) {
            String timeSetToAM = changeToHourFormat(timeWithoutMeridiem + "am");

            String timeSetToPM = changeToHourFormat(timeWithoutMeridiem + "pm");

            SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
            Calendar calendarOfMeridiemKeyed = getCalendar(timeWithMeridiem,
                    dateFormat);

            Calendar calendarMaunalSetToAm = getCalendar(timeSetToAM,
                    dateFormat);

            Calendar calendarMaunalSetToPm = getCalendar(timeSetToPM,
                    dateFormat);

            String timeSelected = getSelectedStartTime(timeSetToAM,
                    timeSetToPM, calendarOfMeridiemKeyed,
                    calendarMaunalSetToAm, calendarMaunalSetToPm);

            assert checkValid24HourTime(timeWithMeridiem) == true : "Wrong convertion of time";
            assert checkValid24HourTime(timeSelected) == true : "Wromg convertion of time";

            addToStorageOfTime(timeWithMeridiem, timeSelected);
        }
    }

    /**
     * add if time selected is not empty
     * 
     * @param timeWithMeridiem
     * @param timeSelected
     */
    private void addToStorageOfTime(String timeWithMeridiem, String timeSelected) {
        if (!timeSelected.equals("")) {
            storageOfTime.add(timeSelected);
            storageOfTime.add(timeWithMeridiem);
        }
    }

    /**
     * to select the start time when only end time have am/pm 1) start time set
     * to am or pm equal to end time with am/pm keyed --> return those not equal
     * 2) two start time set to am or pm before or after end time with am/pm
     * keyed --> get the earliest between start times 3) time in between --> get
     * the latest between two start time
     * 
     * @param timeSetToAM
     * @param timeSetToPM
     * @param calendarOfMeridiemKeyed
     * @param calendarMaunalSetToAm
     * @param calendarMaunalSetToPm
     * @return
     */
    private String getSelectedStartTime(String timeSetToAM, String timeSetToPM,
            Calendar calendarOfMeridiemKeyed, Calendar calendarMaunalSetToAm,
            Calendar calendarMaunalSetToPm) {
        String timeSelected;

        if (calendarOfMeridiemKeyed.equals(calendarMaunalSetToPm)) {
            timeSelected = timeSetToAM;

        } else if (calendarOfMeridiemKeyed.equals(calendarMaunalSetToAm)) {
            timeSelected = timeSetToPM;

        } else if (calendarOfMeridiemKeyed.after(calendarMaunalSetToPm)
                && calendarOfMeridiemKeyed.after(calendarMaunalSetToAm)) {
            timeSelected = timeSetToPM;

        } else if (calendarOfMeridiemKeyed.before(calendarMaunalSetToPm)
                && calendarOfMeridiemKeyed.before(calendarMaunalSetToAm)) {

            timeSelected = timeSetToPM;
        } else {
            timeSelected = timeSetToAM;
        }
        return timeSelected;
    }

    /**
     * add the appropriate end time when only start contain am/pm
     * 
     * @param timeList
     * @throws ParseException
     *             : fail to parse
     */
    private void addTimeWhenStartTimeMeridiem(String[] timeList)
            throws ParseException {

        String timeWithMeridiem = timeList[0];
        String timeWithoutMeridiem = timeList[1];
        timeWithoutMeridiem = timeWithoutMeridiem.trim();
        testValidTime(timeWithMeridiem);
        timeWithMeridiem = changeToHourFormat(timeWithMeridiem);
        timeWithoutMeridiem = changeToHourFormat(timeWithoutMeridiem);

        if (isNotHHMMFormat(timeWithoutMeridiem)) {
            String timeSetToAM = changeToHourFormat(timeWithoutMeridiem + "am");
            String timeSetToPM = changeToHourFormat(timeWithoutMeridiem + "pm");

            SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm");
            Calendar calendarOfMeridiemKeyed = getCalendar(timeWithMeridiem,
                    dateFormat);

            Calendar calendarMaunalSetToAm = getCalendar(timeSetToAM,
                    dateFormat);

            Calendar calendarMaunalSetToPm = getCalendar(timeSetToPM,
                    dateFormat);

            String timeSelected = getSelectedEndTime(timeSetToAM, timeSetToPM,
                    calendarOfMeridiemKeyed, calendarMaunalSetToAm,
                    calendarMaunalSetToPm);

            assert checkValid24HourTime(timeWithMeridiem) == true : "Wrong convertion of time";
            assert checkValid24HourTime(timeSelected) == true : "Wromg convertion of time";

            addToStorageOfTime(timeSelected, timeWithMeridiem);
        }
    }

    /**
     * if it is hhmm, like 2300, we don need to go through this, it will
     * eventually be detected in the subsequent steps
     * 
     * @param timeWithoutMeridiem
     * @return
     */
    private boolean isNotHHMMFormat(String timeWithoutMeridiem) {
        return timeWithoutMeridiem.contains(":")
                || timeWithoutMeridiem.contains(".")
                || timeWithoutMeridiem.contains(",")
                || timeWithoutMeridiem.length() <= 2;
    }

    /**
     * get selected end time when only start time have am/pm 1) end time set to
     * am or pm equal to start time with am/pm keyed --> return those not equal
     * 2) two end time set to am or pm before or after start time with am/pm
     * keyed --> get the earliest between end times 3) time in between --> get
     * the latest between two end time
     * 
     * @param timeSetToAM
     * @param timeSetToPM
     * @param calendarOfMeridiemKeyed
     * @param calendarMaunalSetToAm
     * @param calendarMaunalSetToPm
     * @return
     */
    private String getSelectedEndTime(String timeSetToAM, String timeSetToPM,
            Calendar calendarOfMeridiemKeyed, Calendar calendarMaunalSetToAm,
            Calendar calendarMaunalSetToPm) {
        String timeSelected;
        if (calendarOfMeridiemKeyed.equals(calendarMaunalSetToPm)) {

            timeSelected = timeSetToAM;

        } else if (calendarOfMeridiemKeyed.equals(calendarMaunalSetToAm)) {

            timeSelected = timeSetToPM;

        } else if (calendarOfMeridiemKeyed.after(calendarMaunalSetToPm)
                && calendarOfMeridiemKeyed.after(calendarMaunalSetToAm)) {

            timeSelected = timeSetToAM;

        } else if (calendarOfMeridiemKeyed.before(calendarMaunalSetToPm)
                && calendarOfMeridiemKeyed.before(calendarMaunalSetToAm)) {

            timeSelected = timeSetToAM;

        } else {
            timeSelected = timeSetToPM;
        }
        return timeSelected;
    }

    /**
     * get calendar with specific time set on the same day.
     * 
     * @param timeWithMeridiem
     * @param dateFormat
     * @return
     * @throws ParseException
     *             : fail to parse time
     */
    private Calendar getCalendar(String timeWithMeridiem,
            SimpleDateFormat dateFormat) throws ParseException {

        Date timeContainMeridiem = dateFormat.parse(timeWithMeridiem);
        Calendar calendarOfMeridiemKeyed = Calendar.getInstance();
        calendarOfMeridiemKeyed.setTime(timeContainMeridiem);
        return calendarOfMeridiemKeyed;
    }

    /**
     * determine if the start time contain am or pm
     * 
     * @param timeList
     *            contains times
     * @return true if start time contain otherwise false
     */
    private boolean ifStartTimeContainsAmPm(String[] timeList) {
        boolean ifStartTimeContainsAmPm = false;

        if (timeList[0].contains("a") || timeList[0].contains("p")) {
            ifStartTimeContainsAmPm = true;
        }

        return ifStartTimeContainsAmPm;
    }

    /**
     * get the HH of the time in hour format(HH:MM)
     * 
     * @param time
     * @return HH
     */
    private int getHH(String time) {
        int index = getIndex(time);
        int hhInTime = Integer.parseInt(time.substring(0, index));

        return hhInTime;
    }

    /**
     * get the MM of the time in hour format(HH:MM)
     * 
     * @param pmTime1
     * @return HH
     */
    private String getMinutes(String time) {
        int index = getIndex(time);
        assert index != -1;
        String minutes = time.substring(index + 1);

        return minutes;
    }

    /**
     * throw and catch exception for invalid time for both 24 hour and 12 hour
     * format
     * 
     * @param time
     */
    private void testValidTime(String time) throws IllegalArgumentException {
        int timeInHour, timeInMin;
        Logger logger = Logger.getLogger("TimeParser");
        try {
            logger.log(Level.INFO,
                    "going to start processing for test valid time");

            time = removeUnwantedParts(time);
            boolean isTwelveHour = checkTwelveOrTwentyFourFormat(time);
            time = removePMOrAmOrOclock(time);

            if (time.contains(":") || time.contains(".") || time.contains(",")) {

                timeInHour = getHH(time);
                timeInMin = Integer.parseInt(getMinutes(time));
            } else if (time.length() <= 2) {

                timeInHour = Integer.parseInt(time);
                timeInMin = 0;
            } else if (time.length() == 4) {

                timeInHour = Integer.parseInt(time.substring(0, 2));
                timeInMin = Integer.parseInt(time.substring(2));
            } else {
                timeInHour = 0;
                timeInMin = 0;
            }

            getExceptionForInvalidTime(timeInHour, timeInMin, isTwelveHour);
        } catch (IllegalArgumentException e) {
            logger.log(Level.FINER, "Invalid of time!");
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * get the exception for either 24 hour and 12 hour format
     * 
     * @param timeInHour
     * @param timeInMin
     * @param ifTwelveHour
     * @throws IllegalArgumentException
     *             : invalid 12 (>12) or 24(>23) hour format
     * 
     */
    private void getExceptionForInvalidTime(int timeInHour, int timeInMin,
            boolean ifTwelveHour) throws IllegalArgumentException {
        if (ifTwelveHour) {
            test12HourFormat(timeInHour, timeInMin);
        } else {
            test24HourFormat(timeInHour, timeInMin);
        }
    }

    /**
     * test 12 hour format of 0 <= hour <= 12 and 0 <= minutes <= 60
     * 
     * @param timeInHour
     * @param timeInMin
     * @throws IllegalArgumentException
     *             : beyond 12 for hour or beyond 60 for min
     */
    private void test12HourFormat(int timeInHour, int timeInMin)
            throws IllegalArgumentException {

        if (timeInHour > 12 || timeInHour < 0 || timeInMin < 0
                || timeInMin > 59) {
            throw new IllegalArgumentException(
                    "Time entered in 12-hour format is invalid!");
        }
    }

    /**
     * check if it is 24 hour format or 12 hour format
     * 
     * @param time
     * @return 12 hour format return true and 24 hour format return false
     */
    private boolean checkTwelveOrTwentyFourFormat(String time) {
        boolean isTwelveHour;

        if (time.contains("a") || time.contains("o'clock")
                || time.contains("p") || time.contains("oclock")) {
            isTwelveHour = true;
        } else {
            isTwelveHour = false;
        }

        return isTwelveHour;
    }

    /**
     * test 24 hour format of 0 <= hour <= 23 and 0 <= minutes <= 60
     * 
     * @param timeInHour
     * @param timeInMin
     * @throws IllegalArgumentException
     *             : beyond 23 for hour or beyond 60 for min
     */
    private void test24HourFormat(int timeInHour, int timeInMin)
            throws IllegalArgumentException {
        if (timeInHour > 23 || timeInHour < 0 || timeInMin < 0
                || timeInMin > 59) {
            throw new IllegalArgumentException("Time entered is invalid!");
        }
    }

    /**
     * This is use to test whether my algo manipulate change to 24 hours time
     * format correctly without exceeding the boundary
     * 
     * @param time
     * @return true if 24 hour format does not exceed boundary, false when 24
     *         hours do exceed boundary
     */
    private boolean checkValid24HourTime(String time) {
        int timeInHour, timeInMin;
        boolean validTime = true;

        time = removePMOrAmOrOclock(time);
        time = removeUnwantedParts(time);
        if (time.length() > 2) {
            timeInHour = getHH(time);
            timeInMin = Integer.parseInt(getMinutes(time));
        } else {
            timeInHour = getHH(time);
            timeInMin = 0;
        }
        if (timeInHour > 23 || timeInHour < 0 || timeInMin < 0
                || timeInMin > 59) {
            validTime = false;
        }
        return validTime;
    }

    /**
     * remove the pm and am from the time
     * 
     * @param time
     * @return time without am or pm
     */
    private String removePMOrAmOrOclock(String time) {
        time = time.replaceAll("\\s+|pm|am|a.m.|p.m.|a|p|oclock|o'clock", "");
        return time;
    }

    /**
     * set the position of the time based on which time is typed by the user 1st
     * the time typed by the user 1st is the start time
     * 
     * @param indexNext
     *            : the index in the user input
     */
    private void setThePositionForTime(int indexNext) {

        if (storageOfTime.size() == 2 && indexNext < index) {
            String temp = storageOfTime.get(0);
            storageOfTime.set(0, storageOfTime.get(1));
            storageOfTime.set(1, temp);
        }
        index = indexNext;
    }

    /**
     * detect before noon and before midnight
     * 
     */
    private void spotBeforeMidnightOrNoonKeyword(String userInput) {
        Pattern timeDetector = Pattern
                .compile(BEFORE_NOON_BEFORE_MIDNIGHT_KEYWORD);
        Matcher matchedWithTime = timeDetector.matcher(userInputLeft);
        Matcher matchedForIndex = timeDetector.matcher(userInput);

        while (matchedWithTime.find()) {
            userInputLeft = userInputLeft.replaceAll(
                    BEFORE_NOON_BEFORE_MIDNIGHT_KEYWORD, "");
            String time = matchedWithTime.group();

            if (matchedForIndex.find()) {
                int indexNext = matchedForIndex.start();
                if (time.contains("noon")) {
                    storageOfTime.add("11:59");
                } else if (time.contains("midnight")) {
                    storageOfTime.add("23:59");
                }

                setThePositionForTime(indexNext);
            }
        }
    }

    /**
     * change all of the time inputed to hour format(HH:MM)
     * 
     * @param time
     * @return time in hour format (HH:MM)
     */
    private String changeToHourFormat(String time) {

        time = time.trim();

        if (time.contains("a")) {

            time = removePMOrAmOrOclock(time);
            time = switchToAmHour(time);

        } else if (time.contains("p")) {

            time = removePMOrAmOrOclock(time);
            time = switchToPMHour(time);

        } else if (time.contains(".") || time.contains(",")) {

            time = changePuncToSemicolon(time);

        } else if (!time.contains(":") && time.length() <= 2) {

            time = time + ":00";

        } else if (!time.contains(":") && time.length() == 4) {

            time = time.substring(0, 2) + ":" + time.substring(2);
        }

        time = putOneZeroAtFront(time);

        return time;
    }

    /**
     * when the length is equal to 4 --> H:MM (eg: 2:30) Thus, have to put one
     * zero in front to HH:MM (eg: 02:30)
     * 
     * @param time
     * @return HH:MM
     */
    private String putOneZeroAtFront(String time) {
        time = time.trim();
        if (time.length() == 4) {
            time = "0" + time;
        }
        return time;
    }

    /**
     * switch to 24 hour time format of the time contain am
     * 
     * @param time
     * @return time in HH:MM
     */
    private String switchToAmHour(String time) {

        time = time.trim();
        int index = getIndex(time);

        if (time.length() > 2 && time.charAt(0) == '1' && time.charAt(1) == '2') {

            time = "00" + ":" + time.substring(index + 1);

        } else if (time.length() == 2 && time.charAt(0) == '1'
                && time.charAt(1) == '2') {

            time = "00:00";

        } else if (time.length() == 1) {

            time = "0" + time + ":00";

        } else if (time.length() == 2) {

            time = time + ":00";

        } else if (index != -1 && time.length() == 4) {

            time = "0" + time.substring(0, index) + ":"
                    + time.substring(index + 1);

        } else if (index != -1 && time.length() == 5) {

            time = time.substring(0, index) + ":" + time.substring(index + 1);

        }
        return time;
    }

    /**
     * change the . or , to :
     * 
     * @param time
     * @return time with :
     */
    private String changePuncToSemicolon(String time) {
        time = time.replaceAll("\\.|\\,", ":");
        return time;
    }

    /**
     * get the index of the separation of the HH and MM which is either : or .
     * 
     * @param time
     * @return the index of : or . depend which is detect
     */
    private int getIndex(String time) {
        int indexForPunc = -1;

        if (time.contains(":")) {

            indexForPunc = time.indexOf(":");

        } else if (time.contains(".")) {

            indexForPunc = time.indexOf(".");

        } else if (time.contains(",")) {

            indexForPunc = time.indexOf(",");

        }
        return indexForPunc;
    }

    /**
     * if pm is detected behind the time, switch it to hour format
     * 
     * @param time
     * @return hour format for time in pm.
     */
    private String switchToPMHour(String time) {
        int twentyFourhour = 13, twelveHourTime = 1, hourTime;
        String minTime, hourTimeInString = "";

        if (time.contains(":") || time.contains(".") || time.contains(",")) {
            hourTime = getHH(time);
            minTime = getMinutes(time);

        } else {
            hourTime = Integer.parseInt(time);
            minTime = "00";
        }

        while (twentyFourhour != 24) {
            if (hourTime == 12) {
                hourTimeInString = "12";
                break;
            } else if (hourTime == twelveHourTime) {
                hourTimeInString = String.valueOf(twentyFourhour);
                break;
            } else if (hourTime == 0) {
                hourTimeInString = String.valueOf(hourTime);
            }
            twentyFourhour++;
            twelveHourTime++;
        }

        assert hourTimeInString != "";

        time = hourTimeInString + ":" + minTime;

        return time;
    }

    /**
     * remove the conjunction
     * 
     * @param timeWithUnwantedPart
     * @return time free from conjunction
     */
    public String removeUnwantedParts(String timeWithUnwantedPart) {
        String time;
        time = timeWithUnwantedPart.replaceAll(TO_BE_REMOVED_KEYWORD, "");
        return time;
    }

}

	// End of segment: E:\main\src\parser\TimeParser.java





	/**
	 * origin: E:\main\src\parser\TimeParserTest.java
	 */

 *
 */
public class TimeParserTest {

    @Test
    /*
     * test the escaped char work
     */
    public void timeTestForHashTag() throws Exception {
        ArrayList<String> times = new ArrayList<String>();

        // test when all of the time is ~ ~
        times.clear();

        TimeParser t1 = new TimeParser("mds sale ~11pm to 1:30 pm~.");
        assertEquals(times, t1.getTimeList());
    }

    @Test
    public void testTimeToTime() throws Exception {

        // test without symbol of pm
        ArrayList<String> times = new ArrayList<String>();
        times.clear();
        times.add("06:00");
        times.add("18:00");
        TimeParser dateTime = new TimeParser("mds sale from 6 - 6pm");
        assertEquals(times, dateTime.getTimeList());

        // test without symbol of p
        times.clear();
        times.add("06:00");
        times.add("18:00");
        TimeParser dateTime23 = new TimeParser("mds sale from 6 - 6p");
        assertEquals(times, dateTime23.getTimeList());

        // test without symbol of p.m.
        times.clear();
        times.add("06:00");
        times.add("18:00");
        TimeParser dateTime24 = new TimeParser("mds sale from 6 - 6p");
        assertEquals(times, dateTime24.getTimeList());

        // test without symbol of am
        times.clear();
        times.add("00:00");
        times.add("06:00");
        TimeParser dateTime1 = new TimeParser("mds sale from 12 - 6am");
        assertEquals(times, dateTime1.getTimeList());

        // test without symbol of a
        times.clear();
        times.add("00:00");
        times.add("06:00");
        TimeParser dateTime25 = new TimeParser("mds sale from 12 - 6a");
        assertEquals(times, dateTime25.getTimeList());

        // test without symbol of a.m.
        times.clear();
        times.add("00:00");
        times.add("06:00");
        TimeParser dateTime26 = new TimeParser("mds sale from 12 - 6a.m.");
        assertEquals(times, dateTime26.getTimeList());

        // test with symbol of am and start time < end time
        times.clear();
        times.add("01:30");
        times.add("06:30");
        TimeParser dateTime2 = new TimeParser("mds sale from 1:30 - 6:30am");
        assertEquals(times, dateTime2.getTimeList());

        // test with symbol of pm and start time< end time
        times.clear();
        times.add("15:20");
        times.add("18:10");
        TimeParser dateTime3 = new TimeParser(
                "3:20 - 6:10pm nothing better to do");
        assertEquals(times, dateTime3.getTimeList());

        // test with symbol of pm with . and start time > end time
        times.clear();
        times.add("07:20");
        times.add("18:10");
        TimeParser dateTime8 = new TimeParser(
                "7.20 - 6.10pm nothing better to do");
        assertEquals(times, dateTime8.getTimeList());

        // test with symbol of pm with ,
        times.clear();
        times.add("06:20");
        times.add("18:10");
        TimeParser dateTime14 = new TimeParser(
                "6,20 - 6,10pm nothing better to do");
        assertEquals(times, dateTime14.getTimeList());

        // test with symbol of with both same number and without space
        times.clear();
        times.add("06:20");
        times.add("18:20");
        TimeParser dateTime9 = new TimeParser(
                "6,20-6,20pm nothing better to do");
        assertEquals(times, dateTime9.getTimeList());

        // test with both am
        times.clear();
        times.add("01:00");
        times.add("06:00");
        TimeParser dateTime4 = new TimeParser("mds sale from 1am - 6am");
        assertEquals(times, dateTime4.getTimeList());

        // test with both pm
        times.clear();
        times.add("13:30");
        times.add("18:30");
        TimeParser dateTime5 = new TimeParser("mds sale from 1:30pm - 6:30pm");
        assertEquals(times, dateTime5.getTimeList());

        // test with pm on start time and the start number > end number
        times.clear();
        times.add("21:30");
        times.add("06:30");
        TimeParser dateTime6 = new TimeParser("mds sale from 9:30pm - 6:30");
        assertEquals(times, dateTime6.getTimeList());

        // test with pm on start time, the start number < end number and without
        // no :
        times.clear();
        times.add("13:00");
        times.add("18:00");
        TimeParser dateTime11 = new TimeParser("mds sale from 1pm - 6");
        assertEquals(times, dateTime11.getTimeList());

        // test with am on start time and both end time set to am/pm is after
        // start time
        times.clear();
        times.add("01:30");
        times.add("06:30");
        TimeParser dateTime10 = new TimeParser("mds sale from 1:30am - 6:30");
        assertEquals(times, dateTime10.getTimeList());

        // test with am on start time and both end time set to am/pm is before
        // start time
        // timed test
        times.clear();
        times.add("19:30");
        times.add("05:10");
        TimeParser dateTime12 = new TimeParser("mds sale from 7:30pm - 5:10");
        assertEquals(times, dateTime12.getTimeList());

        // test both with the same time
        times.clear();
        times.add("06:30");
        times.add("18:30");
        TimeParser dateTime13 = new TimeParser("mds sale from 6:30am - 6:30");
        assertEquals(times, dateTime13.getTimeList());

        // test one end time set to am is before and the other set to pm to
        // after
        // start time
        times.clear();
        times.add("04:30");
        times.add("06:30");
        TimeParser dateTime21 = new TimeParser("mds sale from 4:30am-6:30");
        assertEquals(times, dateTime21.getTimeList());

        // test without space
        times.clear();
        times.add("06:30");
        times.add("18:30");
        TimeParser dateTime15 = new TimeParser("mds sale from 6:30am-6:30");
        assertEquals(times, dateTime15.getTimeList());

        // test am behind with both start time after end
        times.clear();
        times.add("20:30");
        times.add("06:30");
        TimeParser dateTime16 = new TimeParser("mds sale from 8:30-6:30am");
        assertEquals(times, dateTime16.getTimeList());

        // test pm/am behind with both start time before end
        times.clear();
        times.add("15:30");
        times.add("20:30");
        TimeParser dateTime17 = new TimeParser("mds sale from 3:30-8:30pm");
        assertEquals(times, dateTime17.getTimeList());

        // test am/pm behind and one am start time before and one pm start time
        // after
        // end time.
        times.clear();
        times.add("07:30");
        times.add("18:30");
        TimeParser dateTime18 = new TimeParser("mds sale from 7:30-6:30pm");
        assertEquals(times, dateTime18.getTimeList());

        // test both same
        times.clear();
        times.add("07:30");
        times.add("19:30");
        TimeParser dateTime19 = new TimeParser("mds sale from 7:30-7:30pm");
        assertEquals(times, dateTime19.getTimeList());

        // test with space
        times.clear();
        times.add("07:30");
        times.add("19:30");
        TimeParser dateTime20 = new TimeParser("mds sale from 7:30 - 7:30pm");
        assertEquals(times, dateTime20.getTimeList());

        // test to instead of - : with semicolon
        // take note "white space"to"white space" then it will work.
        times.clear();
        times.add("01:00");
        times.add("06:30");
        TimeParser dateTime7 = new TimeParser("mds sale from 1:00 to 6:30am");
        assertEquals(times, dateTime7.getTimeList());

        // test to instead of - : with semicolon
        // take note "white space"to"white space" then it will work.
        times.clear();
        times.add("01:00");
        times.add("06:30");
        TimeParser dateTime22 = new TimeParser("mds sale from 1:00am to 6:30");
        assertEquals(times, dateTime22.getTimeList());

    }

    @Test
    public void testPastMidnightOrNoonKeyword() throws Exception {
        // test past midnight
        ArrayList<String> times1 = new ArrayList<String>();
        times1.clear();
        times1.add("00:01");
        TimeParser time = new TimeParser("mds sale start past midnight");
        assertEquals(times1, time.getTimeList());

        // test after midnight
        times1.clear();
        times1.add("00:01");
        TimeParser time3 = new TimeParser("mds sale start after midnight");
        assertEquals(times1, time3.getTimeList());

        // test past noon
        times1.clear();
        times1.add("12:01");
        TimeParser t1 = new TimeParser("past noon run");
        assertEquals(times1, t1.getTimeList());

        // test after noon
        times1.clear();
        times1.add("12:01");
        TimeParser t2 = new TimeParser("after noon run");
        assertEquals(times1, t2.getTimeList());

    }

    @Test
    public void testHourApartKeyword() throws Exception {

        // test boundary of when adding the hour will exceed 23 of pm
        ArrayList<String> times1 = new ArrayList<String>();
        times1.clear();
        times1.add("23:30");
        times1.add("01:30");
        TimeParser t1 = new TimeParser("mds sale start at 11:30pm for 2 hour");
        assertEquals(times1, t1.getTimeList());

        // test symbol of p
        times1.clear();
        times1.add("23:30");
        times1.add("01:30");
        TimeParser t10 = new TimeParser("mds sale start at 11:30p for 2 hour");
        assertEquals(times1, t10.getTimeList());

        // test symbol of p.m.
        times1.clear();
        times1.add("23:30");
        times1.add("01:30");
        TimeParser t11 = new TimeParser(
                "mds sale start at 11:30p.m. for 2 hour");
        assertEquals(times1, t11.getTimeList());

        // test with am/pm in hh:MM
        times1.clear();
        times1.add("11:30");
        times1.add("13:30");
        TimeParser t14 = new TimeParser("mds sale start at 11:30 for 2 hour");
        assertEquals(times1, t14.getTimeList());

        // test with am/pm in hhmm
        times1.clear();
        times1.add("23:30");
        times1.add("01:30");
        TimeParser t15 = new TimeParser("mds sale start at 2330 for 2 hour");
        assertEquals(times1, t15.getTimeList());

        // test pm without semicolon
        times1.clear();
        times1.add("23:00");
        times1.add("01:00");
        TimeParser t2 = new TimeParser("start at 11pm for 2 hours rot");
        assertEquals(times1, t2.getTimeList());

        // test hour apart keyword of am without semicolon and hrs
        times1.clear();
        times1.add("03:00");
        times1.add("05:00");
        TimeParser t3 = new TimeParser("mds sale start at 3am for 2 hrs");
        assertEquals(times1, t3.getTimeList());

        // test symbol a
        times1.clear();
        times1.add("03:00");
        times1.add("05:00");
        TimeParser t12 = new TimeParser("mds sale start at 3a for 2 hrs");
        assertEquals(times1, t12.getTimeList());

        // test symbol a.m.
        times1.clear();
        times1.add("03:00");
        times1.add("05:00");
        TimeParser t13 = new TimeParser("mds sale start at 3 a.m. for 2 hrs");
        assertEquals(times1, t13.getTimeList());

        // test hour apart keyword of am with semicolon and hr
        times1.clear();
        times1.add("03:45");
        times1.add("05:45");

        TimeParser t4 = new TimeParser(("mds sale start at 3:45am for 2 hour"));
        assertEquals(times1, t4.getTimeList());

        // test space sensitively of am
        times1.clear();
        times1.add("03:00");
        times1.add("05:00");

        TimeParser t5 = new TimeParser(("mds sale start at 3 am for 2 hour"));
        assertEquals(times1, t5.getTimeList());

        // test space sensitively of pm
        times1.clear();
        times1.add("15:00");
        times1.add("17:00");

        TimeParser t6 = new TimeParser(("mds sale start at 3 pm for 2 hour"));
        assertEquals(times1, t6.getTimeList());

        // test "," connecting HH and MM
        times1.clear();
        times1.add("02:30");
        times1.add("05:30");

        TimeParser t7 = new TimeParser(("mds sale start at 2,30 am for 3 hour"));
        assertEquals(times1, t7.getTimeList());

        // test "." connecting HH and MM
        times1.clear();
        times1.add("15:30");
        times1.add("17:30");

        TimeParser t8 = new TimeParser(("mds sale start at 3.30 pm for 2 hour"));
        assertEquals(times1, t8.getTimeList());

        // test with am or pm
        times1.clear();
        times1.add("03:30");
        times1.add("05:30");

        TimeParser t9 = new TimeParser(("mds sale start at 3.30 for 2 hour"));
        assertEquals(times1, t9.getTimeList());
    }

    @Test
    public void testBeforeNoonOrMidnight() throws Exception {
        // test for time keyword 3: before noon
        ArrayList<String> times = new ArrayList<String>();
        times.clear();
        times.add("11:59");

        TimeParser t1 = new TimeParser("mds sale before noon");
        assertEquals(times, t1.getTimeList());

        // test before midnight
        times.clear();
        times.add("23:59");

        TimeParser t2 = new TimeParser("before midnight sleep!!!!");
        assertEquals(times, t2.getTimeList());

    }

    @Test
    public void testMorningNightAfternoon() throws Exception {
        // test in night with semicolon
        ArrayList<String> times = new ArrayList<String>();
        times.clear();
        times.add("19:45");

        TimeParser t3 = new TimeParser("mds sale 7:45 in night.");
        assertEquals(times, t3.getTimeList());

        // test in night with at

        times.clear();
        times.add("19:45");

        TimeParser t17 = new TimeParser("mds sale 7:45 at night.");
        assertEquals(times, t17.getTimeList());

        // test in night without in <conjunction>

        times.clear();
        times.add("19:45");

        TimeParser t5 = new TimeParser("mds sale 7:45 night.");
        assertEquals(times, t5.getTimeList());

        // test in morn with semicolon
        times.clear();
        times.add("06:30");

        TimeParser t4 = new TimeParser("6:30 in the morn sunshine");
        assertEquals(times, t4.getTimeList());

        // test in morn without in <conjunction>

        times.clear();
        times.add("07:45");

        TimeParser t14 = new TimeParser("mds sale 7:45 morn.");
        assertEquals(times, t14.getTimeList());

        // test in morning with semicolon
        times.clear();
        times.add("06:30");

        TimeParser t13 = new TimeParser("mds sale at 6:30 in morning");
        assertEquals(times, t13.getTimeList());

        // test in morning without in <conjunction>

        times.clear();
        times.add("07:45");

        TimeParser t15 = new TimeParser("mds sale 7:45 morning.");
        assertEquals(times, t15.getTimeList());

        // test in afternoon with semicolon
        times.clear();
        times.add("14:30");

        TimeParser t6 = new TimeParser("mds sale from 2:30 in afternoon");
        assertEquals(times, t6.getTimeList());

        // test in afternoon without in <conjunction>

        times.clear();
        times.add("14:45");

        TimeParser t16 = new TimeParser("mds sale 2:45 afternoon.");
        assertEquals(times, t16.getTimeList());
        // test in night without semicolon
        times.clear();
        times.add("19:00");

        times.clear();
        times.add("15:00");

        TimeParser t19 = new TimeParser("mds sale 3 at afternoon.");
        assertEquals(times, t19.getTimeList());
        // test in night without semicolon
        times.clear();
        times.add("19:00");

        TimeParser t7 = new TimeParser("mds sale 7 in night");
        assertEquals(times, t7.getTimeList());

        // test in morn without semicolon
        times.clear();
        times.add("06:00");

        TimeParser t8 = new TimeParser("mds sale 6 at morn.");
        assertEquals(times, t8.getTimeList());

        // test in morning without semicolon
        times.clear();
        times.add("03:00");

        TimeParser t9 = new TimeParser("mds sale at 3 in morning.");
        assertEquals(times, t9.getTimeList());

        // test in morning without semicolon
        times.clear();
        times.add("06:00");

        TimeParser t21 = new TimeParser("mds sale 6 at morning.");
        assertEquals(times, t21.getTimeList());

        // test in afternoon without semicolon
        times.clear();
        times.add("14:00");

        TimeParser t10 = new TimeParser("mds sale from 2 in afternoon");
        assertEquals(times, t10.getTimeList());

        // test , connecting mm and hh in time
        times.clear();
        times.add("13:30");

        TimeParser t11 = new TimeParser("mds sale from 1,30 in afternoon");
        assertEquals(times, t11.getTimeList());

        // test . connecting mm and hh in time
        times.clear();
        times.add("23:30");

        TimeParser t12 = new TimeParser("mds sale from 11.30 in night");
        assertEquals(times, t12.getTimeList());

    }

    @Test
    /*
     * test time of o'clock 1) HH:MM o'clock 2) HH,MM o'clock 3) HH.MM o'clock
     * 4) HH o'clock 5) space sensitivity
     */
    public void testTimeWithOclock() throws Exception {
        ArrayList<String> times = new ArrayList<String>();
        // test HH o'clock
        times.clear();
        times.add("10:00");

        TimeParser t1 = new TimeParser(
                ("add go run one round on this sun from 10 oclock"));
        assertEquals(times, t1.getTimeList());

        // test HH:MM o'clock
        times.clear();
        times.add("11:45");

        TimeParser t2 = new TimeParser(("mds sale start at 11:45 o'clock"));
        assertEquals(times, t2.getTimeList());

        // test HH.MM o'clock
        times.clear();
        times.add("11:45");

        TimeParser t3 = new TimeParser(("mds sale start at 11.45 o'clock"));
        assertEquals(times, t3.getTimeList());

        // test HH,MM o'clock
        times.clear();
        times.add("11:45");

        TimeParser t4 = new TimeParser(("11,45 o'clock go go go"));
        assertEquals(times, t4.getTimeList());

        // test space sensitively
        times.clear();
        times.add("11:45");

        TimeParser t5 = new TimeParser(("mds sale start at 11.45o'clock"));
        assertEquals(times, t5.getTimeList());
    }

    @Test
    public void testHourFormat() throws Exception {
        ArrayList<String> times = new ArrayList<String>();

        // test with symbol "."
        times.clear();
        times.add("23:20");

        TimeParser t1 = new TimeParser(("mds sale 23.20"));
        assertEquals(times, t1.getTimeList());

        // test with symbol ","
        times.clear();
        times.add("00:20");

        TimeParser t2 = new TimeParser(("mds sale 00,20"));
        assertEquals(times, t2.getTimeList());

        // test with symbol ":"
        times.clear();
        times.add("11:20");
        TimeParser t3 = new TimeParser("mds sale 11:20");
        assertEquals(times, t3.getTimeList());

    }

    @Test
    /*
     * test digit pm/am hour format am/pm
     */
    public void testTwelveHourTime() throws Exception {
        // test with semicolon format of am
        ArrayList<String> times = new ArrayList<String>();
        times.clear();
        times.add("00:30");
        TimeParser t1 = new TimeParser(("mds sale 12:30 am 24/3/2014"));
        assertEquals(times, t1.getTimeList());

        // test with no semicolon of am
        times.clear();
        times.add("00:00");
        TimeParser t2 = new TimeParser(("mds sale 12 am 24/3/2014"));
        assertEquals(times, t2.getTimeList());

        // test for of pm without semicolon
        times.clear();
        times.add("18:00");
        TimeParser t3 = new TimeParser(("6pm"));
        assertEquals(times, t3.getTimeList());

        // test for pm with semicolon
        times.clear();
        times.add("18:30");
        TimeParser t4 = new TimeParser(("mds sale at 6:30pm"));
        assertEquals(times, t4.getTimeList());

        // test for time with "." connecting HH and MM
        times.clear();
        times.add("18:30");
        TimeParser t5 = new TimeParser(("mds sale at 6.30pm"));
        assertEquals(times, t5.getTimeList());

        // test for time with "," connecting HH and MM
        times.clear();
        times.add("15:30");
        TimeParser t6 = new TimeParser(("mds sale at 3,30pm"));
        assertEquals(times, t6.getTimeList());

        // test for hhmm
        times.clear();
        times.add("23:00");
        TimeParser t7 = new TimeParser(("mds sale at 2300"));
        assertEquals(times, t7.getTimeList());

        // test with semicolon format of a
        times.clear();
        times.add("00:30");
        TimeParser t8 = new TimeParser(("mds sale 12:30 a 24/3/2014"));
        assertEquals(times, t8.getTimeList());

        // test with semicolon format of a.m.
        times.clear();
        times.add("00:30");
        TimeParser t9 = new TimeParser(("mds sale 12:30 a.m. 24/3/2014"));
        assertEquals(times, t9.getTimeList());

        // test with semicolon format of p.m.
        times.clear();
        times.add("12:30");
        TimeParser t10 = new TimeParser(("mds sale 12:30 p.m. 24/3/2014"));
        assertEquals(times, t10.getTimeList());

        // test with semicolon format of p
        times.clear();
        times.add("12:30");
        TimeParser t11 = new TimeParser(("mds sale 12:30 p 24/3/2014"));
        assertEquals(times, t11.getTimeList());

    }

    @Test
    /*
     * test for the position of the time
     */
    public void testPosition() throws Exception {
        /*
         * test the position of time is right since program will 1st detect
         * start at 11am for 1 hours then detect noonbut the arrangement of the
         * timing should be noon --> before midnight
         */
        ArrayList<String> times = new ArrayList<String>();
        times.clear();
        times.add("11:00");
        times.add("12:00");
        times.add("23:59");
        TimeParser t1 = new TimeParser(
                ("mds sale from before midnight start at 11am for 1 hours"));

        assertEquals(times, t1.getTimeList());

    }

}

	// End of segment: E:\main\src\parser\TimeParserTest.java





	/**
	 * origin: E:\main\src\parser\WeekDayParser.java
	 */

 *
 */
public class WeekDayParser {

    public WeekDayParser() {

    }

    /**
     * add the weekday to the date
     * 
     * @param date : in dd/mm/yyyy format
     */
    public static String getWeekDay(String date)
            throws IllegalArgumentException {

        Calendar calendar = Calendar.getInstance();

        int day = NumberParser.getNumber(date);
        int year = YearParser.getYear(date);
        int month = MonthParser.getMonth(date);

        setDateIntoCalendar(day, month - 1, year, calendar);

        testValidDay(day, year, month);
        testValidMonth(month);

        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK) - 1;

        String weekdayInWord = convertToWord(dayOfWeek);

        return weekdayInWord;
    }

    public static int detectDayOfWeek(String userInput) {
        int dayOfWeek = 0;

        if (userInput.contains("mon")) {
            dayOfWeek = 1;
        } else if (userInput.contains("tue")) {
            dayOfWeek = 2;
        } else if (userInput.contains("wed")) {
            dayOfWeek = 3;
        } else if (userInput.contains("thur")) {
            dayOfWeek = 4;
        } else if (userInput.contains("fri")) {
            dayOfWeek = 5;
        } else if (userInput.contains("sat")) {
            dayOfWeek = 6;
        } else if (userInput.contains("sun")) {
            dayOfWeek = 7;
        }

        return dayOfWeek;
    }

    /**
     * check if the date is valid if the year and the month have this day For
     * example feb only have max 29 days
     * 
     * @param day
     * @throws IllegalArgumentException
     *             : when the day of month exceeded
     */
    private static void testValidDay(int day, int year, int month)
            throws IllegalArgumentException {

        try {

            Calendar calendar = Calendar.getInstance();

            if (year != 0) {
                calendar.set(Calendar.YEAR, year);
            }

            calendar.set(Calendar.MONTH, month - 1);

            int maxDays = calendar.getActualMaximum(Calendar.DAY_OF_MONTH);

            if (day == 0 || maxDays < day) {
                throw new IllegalArgumentException(
                        "Invalid Day Keyed! Exceed the maximum day in that month");
            }

        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * throws and catch exception of invalid month
     * 
     * @param month
     * @throws IllegalArgumentException
     *             : month > 12 or month <= 0
     */
    private static void testValidMonth(int month)
            throws IllegalArgumentException {
        try {
            if (month <= 0 || month > 12) {
                throw new IllegalArgumentException("Invalid Month Keyed!");
            }
        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(null, e.getMessage());
            throw new IllegalArgumentException(e.getMessage());
        }
    }

    /**
     * convert to word for all week day integer
     * 
     * @param dayOfWeek
     * @return
     */
    private static String convertToWord(int dayOfWeek) {
        String dayOfWeekInWord = "";

        if (dayOfWeek == 1) {
            dayOfWeekInWord = "Mon";
        } else if (dayOfWeek == 2) {
            dayOfWeekInWord = "Tues";
        } else if (dayOfWeek == 3) {
            dayOfWeekInWord = "Wed";
        } else if (dayOfWeek == 4) {
            dayOfWeekInWord = "Thur";
        } else if (dayOfWeek == 5) {
            dayOfWeekInWord = "Fri";
        } else if (dayOfWeek == 6) {
            dayOfWeekInWord = "Sat";
        } else if (dayOfWeek == 0) {
            dayOfWeekInWord = "Sun";
        }
        return dayOfWeekInWord;
    }

    /**
     * set day, month, year into the calendar after detected
     * 
     * @param dateOfTheTask
     * @param calendar
     */
    private static void setDateIntoCalendar(int day, int month, int year,
            Calendar calendar) {
        calendar.set(Calendar.DATE, day);
        calendar.set(Calendar.YEAR, year);
        calendar.set(Calendar.MONTH, month);
    }

}

	// End of segment: E:\main\src\parser\WeekDayParser.java





	/**
	 * origin: E:\main\src\parser\WeekDayParserTest.java
	 */

 *
 */
public class WeekDayParserTest {

    @Test
    public void test() {

        assertEquals(WeekDayParser.getWeekDay("03/04/2015"), "Fri");
        assertEquals(WeekDayParser.getWeekDay("04/04/2015"), "Sat");
        assertEquals(WeekDayParser.getWeekDay("05/04/2015"), "Sun");
        assertEquals(WeekDayParser.getWeekDay("06/04/2015"), "Mon");
        assertEquals(WeekDayParser.getWeekDay("07/04/2015"), "Tues");
        assertEquals(WeekDayParser.getWeekDay("08/04/2015"), "Wed");
        assertEquals(WeekDayParser.getWeekDay("09/04/2015"), "Thur");

        assertEquals(WeekDayParser.detectDayOfWeek("hdhdhd"), 0);
        assertEquals(WeekDayParser.detectDayOfWeek("friday"), 5);
        assertEquals(WeekDayParser.detectDayOfWeek("satuarday"), 6);
        assertEquals(WeekDayParser.detectDayOfWeek("sunday"), 7);
        assertEquals(WeekDayParser.detectDayOfWeek("monday"), 1);
        assertEquals(WeekDayParser.detectDayOfWeek("tuesday"), 2);
        assertEquals(WeekDayParser.detectDayOfWeek("wednesday"), 3);
        assertEquals(WeekDayParser.detectDayOfWeek("thursday"), 4);

    }

}

	// End of segment: E:\main\src\parser\WeekDayParserTest.java





	/**
	 * origin: E:\main\src\parser\YearParser.java
	 */

 *
 */
public class YearParser {

    public YearParser() {

    }

    public static int getYear(String dateOfTheTask) {
        int year = 0;
        Pattern numberPattern = Pattern.compile("\\d+");
        Matcher containYear = numberPattern.matcher(dateOfTheTask);
        String numberText;

        while (containYear.find()) {
            numberText = containYear.group();

            if (numberText.length() == 4) {
                year = Integer.parseInt(numberText);
            }
        }
        return year;
    }
}

	// End of segment: E:\main\src\parser\YearParser.java





	/**
	 * origin: E:\main\src\parser\YearParserTest.java
	 */

 *
 */
public class YearParserTest {

    @Test
    public void test() {
        // test in dd/mm/yyyy
        assertEquals(2014, YearParser.getYear("24/05/2014"));

        // test in dd/mm
        assertEquals(0, YearParser.getYear("24/05"));

        // test in mm/dd/yyyy
        assertEquals(2016, YearParser.getYear("Apr 05 2016"));

        // test in mm/dd
        assertEquals(0, YearParser.getYear("Apr 05 "));

        // test in dd/mm/yyyy
        assertEquals(2013, YearParser.getYear("05 Feb 2013"));

        // test in dd/mm
        assertEquals(0, YearParser.getYear("19 Oct"));

        // year not in length YYYY
        assertEquals(0, YearParser.getYear("19 Oct 19"));
    }
}

	// End of segment: E:\main\src\parser\YearParserTest.java





